// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gtfs-realtime.proto

#ifndef PROTOBUF_gtfs_2drealtime_2eproto__INCLUDED
#define PROTOBUF_gtfs_2drealtime_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace transit_realtime {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_gtfs_2drealtime_2eproto();
void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();

class Alert;
class EntitySelector;
class FeedEntity;
class FeedHeader;
class FeedMessage;
class OVapiVehiclePosition;
class Position;
class TimeRange;
class TranslatedString;
class TranslatedString_Translation;
class TripDescriptor;
class TripUpdate;
class TripUpdate_StopTimeEvent;
class TripUpdate_StopTimeUpdate;
class VehicleDescriptor;
class VehiclePosition;

enum FeedHeader_Incrementality {
  FeedHeader_Incrementality_FULL_DATASET = 0,
  FeedHeader_Incrementality_DIFFERENTIAL = 1
};
bool FeedHeader_Incrementality_IsValid(int value);
const FeedHeader_Incrementality FeedHeader_Incrementality_Incrementality_MIN = FeedHeader_Incrementality_FULL_DATASET;
const FeedHeader_Incrementality FeedHeader_Incrementality_Incrementality_MAX = FeedHeader_Incrementality_DIFFERENTIAL;
const int FeedHeader_Incrementality_Incrementality_ARRAYSIZE = FeedHeader_Incrementality_Incrementality_MAX + 1;

const ::google::protobuf::EnumDescriptor* FeedHeader_Incrementality_descriptor();
inline const ::std::string& FeedHeader_Incrementality_Name(FeedHeader_Incrementality value) {
  return ::google::protobuf::internal::NameOfEnum(
    FeedHeader_Incrementality_descriptor(), value);
}
inline bool FeedHeader_Incrementality_Parse(
    const ::std::string& name, FeedHeader_Incrementality* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FeedHeader_Incrementality>(
    FeedHeader_Incrementality_descriptor(), name, value);
}
enum TripUpdate_StopTimeUpdate_ScheduleRelationship {
  TripUpdate_StopTimeUpdate_ScheduleRelationship_SCHEDULED = 0,
  TripUpdate_StopTimeUpdate_ScheduleRelationship_SKIPPED = 1,
  TripUpdate_StopTimeUpdate_ScheduleRelationship_NO_DATA = 2,
  TripUpdate_StopTimeUpdate_ScheduleRelationship_ADDED = 3
};
bool TripUpdate_StopTimeUpdate_ScheduleRelationship_IsValid(int value);
const TripUpdate_StopTimeUpdate_ScheduleRelationship TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_MIN = TripUpdate_StopTimeUpdate_ScheduleRelationship_SCHEDULED;
const TripUpdate_StopTimeUpdate_ScheduleRelationship TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_MAX = TripUpdate_StopTimeUpdate_ScheduleRelationship_ADDED;
const int TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_ARRAYSIZE = TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_MAX + 1;

const ::google::protobuf::EnumDescriptor* TripUpdate_StopTimeUpdate_ScheduleRelationship_descriptor();
inline const ::std::string& TripUpdate_StopTimeUpdate_ScheduleRelationship_Name(TripUpdate_StopTimeUpdate_ScheduleRelationship value) {
  return ::google::protobuf::internal::NameOfEnum(
    TripUpdate_StopTimeUpdate_ScheduleRelationship_descriptor(), value);
}
inline bool TripUpdate_StopTimeUpdate_ScheduleRelationship_Parse(
    const ::std::string& name, TripUpdate_StopTimeUpdate_ScheduleRelationship* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TripUpdate_StopTimeUpdate_ScheduleRelationship>(
    TripUpdate_StopTimeUpdate_ScheduleRelationship_descriptor(), name, value);
}
enum VehiclePosition_VehicleStopStatus {
  VehiclePosition_VehicleStopStatus_INCOMING_AT = 0,
  VehiclePosition_VehicleStopStatus_STOPPED_AT = 1,
  VehiclePosition_VehicleStopStatus_IN_TRANSIT_TO = 2
};
bool VehiclePosition_VehicleStopStatus_IsValid(int value);
const VehiclePosition_VehicleStopStatus VehiclePosition_VehicleStopStatus_VehicleStopStatus_MIN = VehiclePosition_VehicleStopStatus_INCOMING_AT;
const VehiclePosition_VehicleStopStatus VehiclePosition_VehicleStopStatus_VehicleStopStatus_MAX = VehiclePosition_VehicleStopStatus_IN_TRANSIT_TO;
const int VehiclePosition_VehicleStopStatus_VehicleStopStatus_ARRAYSIZE = VehiclePosition_VehicleStopStatus_VehicleStopStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* VehiclePosition_VehicleStopStatus_descriptor();
inline const ::std::string& VehiclePosition_VehicleStopStatus_Name(VehiclePosition_VehicleStopStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    VehiclePosition_VehicleStopStatus_descriptor(), value);
}
inline bool VehiclePosition_VehicleStopStatus_Parse(
    const ::std::string& name, VehiclePosition_VehicleStopStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VehiclePosition_VehicleStopStatus>(
    VehiclePosition_VehicleStopStatus_descriptor(), name, value);
}
enum VehiclePosition_CongestionLevel {
  VehiclePosition_CongestionLevel_UNKNOWN_CONGESTION_LEVEL = 0,
  VehiclePosition_CongestionLevel_RUNNING_SMOOTHLY = 1,
  VehiclePosition_CongestionLevel_STOP_AND_GO = 2,
  VehiclePosition_CongestionLevel_CONGESTION = 3,
  VehiclePosition_CongestionLevel_SEVERE_CONGESTION = 4
};
bool VehiclePosition_CongestionLevel_IsValid(int value);
const VehiclePosition_CongestionLevel VehiclePosition_CongestionLevel_CongestionLevel_MIN = VehiclePosition_CongestionLevel_UNKNOWN_CONGESTION_LEVEL;
const VehiclePosition_CongestionLevel VehiclePosition_CongestionLevel_CongestionLevel_MAX = VehiclePosition_CongestionLevel_SEVERE_CONGESTION;
const int VehiclePosition_CongestionLevel_CongestionLevel_ARRAYSIZE = VehiclePosition_CongestionLevel_CongestionLevel_MAX + 1;

const ::google::protobuf::EnumDescriptor* VehiclePosition_CongestionLevel_descriptor();
inline const ::std::string& VehiclePosition_CongestionLevel_Name(VehiclePosition_CongestionLevel value) {
  return ::google::protobuf::internal::NameOfEnum(
    VehiclePosition_CongestionLevel_descriptor(), value);
}
inline bool VehiclePosition_CongestionLevel_Parse(
    const ::std::string& name, VehiclePosition_CongestionLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VehiclePosition_CongestionLevel>(
    VehiclePosition_CongestionLevel_descriptor(), name, value);
}
enum Alert_Cause {
  Alert_Cause_UNKNOWN_CAUSE = 1,
  Alert_Cause_OTHER_CAUSE = 2,
  Alert_Cause_TECHNICAL_PROBLEM = 3,
  Alert_Cause_STRIKE = 4,
  Alert_Cause_DEMONSTRATION = 5,
  Alert_Cause_ACCIDENT = 6,
  Alert_Cause_HOLIDAY = 7,
  Alert_Cause_WEATHER = 8,
  Alert_Cause_MAINTENANCE = 9,
  Alert_Cause_CONSTRUCTION = 10,
  Alert_Cause_POLICE_ACTIVITY = 11,
  Alert_Cause_MEDICAL_EMERGENCY = 12
};
bool Alert_Cause_IsValid(int value);
const Alert_Cause Alert_Cause_Cause_MIN = Alert_Cause_UNKNOWN_CAUSE;
const Alert_Cause Alert_Cause_Cause_MAX = Alert_Cause_MEDICAL_EMERGENCY;
const int Alert_Cause_Cause_ARRAYSIZE = Alert_Cause_Cause_MAX + 1;

const ::google::protobuf::EnumDescriptor* Alert_Cause_descriptor();
inline const ::std::string& Alert_Cause_Name(Alert_Cause value) {
  return ::google::protobuf::internal::NameOfEnum(
    Alert_Cause_descriptor(), value);
}
inline bool Alert_Cause_Parse(
    const ::std::string& name, Alert_Cause* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Alert_Cause>(
    Alert_Cause_descriptor(), name, value);
}
enum Alert_Effect {
  Alert_Effect_NO_SERVICE = 1,
  Alert_Effect_REDUCED_SERVICE = 2,
  Alert_Effect_SIGNIFICANT_DELAYS = 3,
  Alert_Effect_DETOUR = 4,
  Alert_Effect_ADDITIONAL_SERVICE = 5,
  Alert_Effect_MODIFIED_SERVICE = 6,
  Alert_Effect_OTHER_EFFECT = 7,
  Alert_Effect_UNKNOWN_EFFECT = 8,
  Alert_Effect_STOP_MOVED = 9
};
bool Alert_Effect_IsValid(int value);
const Alert_Effect Alert_Effect_Effect_MIN = Alert_Effect_NO_SERVICE;
const Alert_Effect Alert_Effect_Effect_MAX = Alert_Effect_STOP_MOVED;
const int Alert_Effect_Effect_ARRAYSIZE = Alert_Effect_Effect_MAX + 1;

const ::google::protobuf::EnumDescriptor* Alert_Effect_descriptor();
inline const ::std::string& Alert_Effect_Name(Alert_Effect value) {
  return ::google::protobuf::internal::NameOfEnum(
    Alert_Effect_descriptor(), value);
}
inline bool Alert_Effect_Parse(
    const ::std::string& name, Alert_Effect* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Alert_Effect>(
    Alert_Effect_descriptor(), name, value);
}
enum TripDescriptor_ScheduleRelationship {
  TripDescriptor_ScheduleRelationship_SCHEDULED = 0,
  TripDescriptor_ScheduleRelationship_ADDED = 1,
  TripDescriptor_ScheduleRelationship_UNSCHEDULED = 2,
  TripDescriptor_ScheduleRelationship_CANCELED = 3,
  TripDescriptor_ScheduleRelationship_REPLACEMENT = 5
};
bool TripDescriptor_ScheduleRelationship_IsValid(int value);
const TripDescriptor_ScheduleRelationship TripDescriptor_ScheduleRelationship_ScheduleRelationship_MIN = TripDescriptor_ScheduleRelationship_SCHEDULED;
const TripDescriptor_ScheduleRelationship TripDescriptor_ScheduleRelationship_ScheduleRelationship_MAX = TripDescriptor_ScheduleRelationship_REPLACEMENT;
const int TripDescriptor_ScheduleRelationship_ScheduleRelationship_ARRAYSIZE = TripDescriptor_ScheduleRelationship_ScheduleRelationship_MAX + 1;

const ::google::protobuf::EnumDescriptor* TripDescriptor_ScheduleRelationship_descriptor();
inline const ::std::string& TripDescriptor_ScheduleRelationship_Name(TripDescriptor_ScheduleRelationship value) {
  return ::google::protobuf::internal::NameOfEnum(
    TripDescriptor_ScheduleRelationship_descriptor(), value);
}
inline bool TripDescriptor_ScheduleRelationship_Parse(
    const ::std::string& name, TripDescriptor_ScheduleRelationship* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TripDescriptor_ScheduleRelationship>(
    TripDescriptor_ScheduleRelationship_descriptor(), name, value);
}
// ===================================================================

class FeedMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:transit_realtime.FeedMessage) */ {
 public:
  FeedMessage();
  virtual ~FeedMessage();

  FeedMessage(const FeedMessage& from);

  inline FeedMessage& operator=(const FeedMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FeedMessage& default_instance();

  void Swap(FeedMessage* other);

  // implements Message ----------------------------------------------

  inline FeedMessage* New() const { return New(NULL); }

  FeedMessage* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FeedMessage& from);
  void MergeFrom(const FeedMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FeedMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .transit_realtime.FeedHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::transit_realtime::FeedHeader& header() const;
  ::transit_realtime::FeedHeader* mutable_header();
  ::transit_realtime::FeedHeader* release_header();
  void set_allocated_header(::transit_realtime::FeedHeader* header);

  // repeated .transit_realtime.FeedEntity entity = 2;
  int entity_size() const;
  void clear_entity();
  static const int kEntityFieldNumber = 2;
  const ::transit_realtime::FeedEntity& entity(int index) const;
  ::transit_realtime::FeedEntity* mutable_entity(int index);
  ::transit_realtime::FeedEntity* add_entity();
  ::google::protobuf::RepeatedPtrField< ::transit_realtime::FeedEntity >*
      mutable_entity();
  const ::google::protobuf::RepeatedPtrField< ::transit_realtime::FeedEntity >&
      entity() const;

  // @@protoc_insertion_point(class_scope:transit_realtime.FeedMessage)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::transit_realtime::FeedHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::transit_realtime::FeedEntity > entity_;
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();

  void InitAsDefaultInstance();
  static FeedMessage* default_instance_;
};
// -------------------------------------------------------------------

class FeedHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:transit_realtime.FeedHeader) */ {
 public:
  FeedHeader();
  virtual ~FeedHeader();

  FeedHeader(const FeedHeader& from);

  inline FeedHeader& operator=(const FeedHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FeedHeader& default_instance();

  void Swap(FeedHeader* other);

  // implements Message ----------------------------------------------

  inline FeedHeader* New() const { return New(NULL); }

  FeedHeader* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FeedHeader& from);
  void MergeFrom(const FeedHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FeedHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef FeedHeader_Incrementality Incrementality;
  static const Incrementality FULL_DATASET =
    FeedHeader_Incrementality_FULL_DATASET;
  static const Incrementality DIFFERENTIAL =
    FeedHeader_Incrementality_DIFFERENTIAL;
  static inline bool Incrementality_IsValid(int value) {
    return FeedHeader_Incrementality_IsValid(value);
  }
  static const Incrementality Incrementality_MIN =
    FeedHeader_Incrementality_Incrementality_MIN;
  static const Incrementality Incrementality_MAX =
    FeedHeader_Incrementality_Incrementality_MAX;
  static const int Incrementality_ARRAYSIZE =
    FeedHeader_Incrementality_Incrementality_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Incrementality_descriptor() {
    return FeedHeader_Incrementality_descriptor();
  }
  static inline const ::std::string& Incrementality_Name(Incrementality value) {
    return FeedHeader_Incrementality_Name(value);
  }
  static inline bool Incrementality_Parse(const ::std::string& name,
      Incrementality* value) {
    return FeedHeader_Incrementality_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string gtfs_realtime_version = 1;
  bool has_gtfs_realtime_version() const;
  void clear_gtfs_realtime_version();
  static const int kGtfsRealtimeVersionFieldNumber = 1;
  const ::std::string& gtfs_realtime_version() const;
  void set_gtfs_realtime_version(const ::std::string& value);
  void set_gtfs_realtime_version(const char* value);
  void set_gtfs_realtime_version(const char* value, size_t size);
  ::std::string* mutable_gtfs_realtime_version();
  ::std::string* release_gtfs_realtime_version();
  void set_allocated_gtfs_realtime_version(::std::string* gtfs_realtime_version);

  // optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET];
  bool has_incrementality() const;
  void clear_incrementality();
  static const int kIncrementalityFieldNumber = 2;
  ::transit_realtime::FeedHeader_Incrementality incrementality() const;
  void set_incrementality(::transit_realtime::FeedHeader_Incrementality value);

  // optional uint64 timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(FeedHeader)
  // @@protoc_insertion_point(class_scope:transit_realtime.FeedHeader)
 private:
  inline void set_has_gtfs_realtime_version();
  inline void clear_has_gtfs_realtime_version();
  inline void set_has_incrementality();
  inline void clear_has_incrementality();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr gtfs_realtime_version_;
  ::google::protobuf::uint64 timestamp_;
  int incrementality_;
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();

  void InitAsDefaultInstance();
  static FeedHeader* default_instance_;
};
// -------------------------------------------------------------------

class FeedEntity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:transit_realtime.FeedEntity) */ {
 public:
  FeedEntity();
  virtual ~FeedEntity();

  FeedEntity(const FeedEntity& from);

  inline FeedEntity& operator=(const FeedEntity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FeedEntity& default_instance();

  void Swap(FeedEntity* other);

  // implements Message ----------------------------------------------

  inline FeedEntity* New() const { return New(NULL); }

  FeedEntity* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FeedEntity& from);
  void MergeFrom(const FeedEntity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FeedEntity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional bool is_deleted = 2 [default = false];
  bool has_is_deleted() const;
  void clear_is_deleted();
  static const int kIsDeletedFieldNumber = 2;
  bool is_deleted() const;
  void set_is_deleted(bool value);

  // optional .transit_realtime.TripUpdate trip_update = 3;
  bool has_trip_update() const;
  void clear_trip_update();
  static const int kTripUpdateFieldNumber = 3;
  const ::transit_realtime::TripUpdate& trip_update() const;
  ::transit_realtime::TripUpdate* mutable_trip_update();
  ::transit_realtime::TripUpdate* release_trip_update();
  void set_allocated_trip_update(::transit_realtime::TripUpdate* trip_update);

  // optional .transit_realtime.VehiclePosition vehicle = 4;
  bool has_vehicle() const;
  void clear_vehicle();
  static const int kVehicleFieldNumber = 4;
  const ::transit_realtime::VehiclePosition& vehicle() const;
  ::transit_realtime::VehiclePosition* mutable_vehicle();
  ::transit_realtime::VehiclePosition* release_vehicle();
  void set_allocated_vehicle(::transit_realtime::VehiclePosition* vehicle);

  // optional .transit_realtime.Alert alert = 5;
  bool has_alert() const;
  void clear_alert();
  static const int kAlertFieldNumber = 5;
  const ::transit_realtime::Alert& alert() const;
  ::transit_realtime::Alert* mutable_alert();
  ::transit_realtime::Alert* release_alert();
  void set_allocated_alert(::transit_realtime::Alert* alert);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(FeedEntity)
  // @@protoc_insertion_point(class_scope:transit_realtime.FeedEntity)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_is_deleted();
  inline void clear_has_is_deleted();
  inline void set_has_trip_update();
  inline void clear_has_trip_update();
  inline void set_has_vehicle();
  inline void clear_has_vehicle();
  inline void set_has_alert();
  inline void clear_has_alert();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::transit_realtime::TripUpdate* trip_update_;
  ::transit_realtime::VehiclePosition* vehicle_;
  ::transit_realtime::Alert* alert_;
  bool is_deleted_;
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();

  void InitAsDefaultInstance();
  static FeedEntity* default_instance_;
};
// -------------------------------------------------------------------

class TripUpdate_StopTimeEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:transit_realtime.TripUpdate.StopTimeEvent) */ {
 public:
  TripUpdate_StopTimeEvent();
  virtual ~TripUpdate_StopTimeEvent();

  TripUpdate_StopTimeEvent(const TripUpdate_StopTimeEvent& from);

  inline TripUpdate_StopTimeEvent& operator=(const TripUpdate_StopTimeEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TripUpdate_StopTimeEvent& default_instance();

  void Swap(TripUpdate_StopTimeEvent* other);

  // implements Message ----------------------------------------------

  inline TripUpdate_StopTimeEvent* New() const { return New(NULL); }

  TripUpdate_StopTimeEvent* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TripUpdate_StopTimeEvent& from);
  void MergeFrom(const TripUpdate_StopTimeEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripUpdate_StopTimeEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 delay = 1;
  bool has_delay() const;
  void clear_delay();
  static const int kDelayFieldNumber = 1;
  ::google::protobuf::int32 delay() const;
  void set_delay(::google::protobuf::int32 value);

  // optional int64 time = 2;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  ::google::protobuf::int64 time() const;
  void set_time(::google::protobuf::int64 value);

  // optional int32 uncertainty = 3;
  bool has_uncertainty() const;
  void clear_uncertainty();
  static const int kUncertaintyFieldNumber = 3;
  ::google::protobuf::int32 uncertainty() const;
  void set_uncertainty(::google::protobuf::int32 value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(TripUpdate_StopTimeEvent)
  // @@protoc_insertion_point(class_scope:transit_realtime.TripUpdate.StopTimeEvent)
 private:
  inline void set_has_delay();
  inline void clear_has_delay();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_uncertainty();
  inline void clear_has_uncertainty();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 time_;
  ::google::protobuf::int32 delay_;
  ::google::protobuf::int32 uncertainty_;
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();

  void InitAsDefaultInstance();
  static TripUpdate_StopTimeEvent* default_instance_;
};
// -------------------------------------------------------------------

class TripUpdate_StopTimeUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:transit_realtime.TripUpdate.StopTimeUpdate) */ {
 public:
  TripUpdate_StopTimeUpdate();
  virtual ~TripUpdate_StopTimeUpdate();

  TripUpdate_StopTimeUpdate(const TripUpdate_StopTimeUpdate& from);

  inline TripUpdate_StopTimeUpdate& operator=(const TripUpdate_StopTimeUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TripUpdate_StopTimeUpdate& default_instance();

  void Swap(TripUpdate_StopTimeUpdate* other);

  // implements Message ----------------------------------------------

  inline TripUpdate_StopTimeUpdate* New() const { return New(NULL); }

  TripUpdate_StopTimeUpdate* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TripUpdate_StopTimeUpdate& from);
  void MergeFrom(const TripUpdate_StopTimeUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripUpdate_StopTimeUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TripUpdate_StopTimeUpdate_ScheduleRelationship ScheduleRelationship;
  static const ScheduleRelationship SCHEDULED =
    TripUpdate_StopTimeUpdate_ScheduleRelationship_SCHEDULED;
  static const ScheduleRelationship SKIPPED =
    TripUpdate_StopTimeUpdate_ScheduleRelationship_SKIPPED;
  static const ScheduleRelationship NO_DATA =
    TripUpdate_StopTimeUpdate_ScheduleRelationship_NO_DATA;
  static const ScheduleRelationship ADDED =
    TripUpdate_StopTimeUpdate_ScheduleRelationship_ADDED;
  static inline bool ScheduleRelationship_IsValid(int value) {
    return TripUpdate_StopTimeUpdate_ScheduleRelationship_IsValid(value);
  }
  static const ScheduleRelationship ScheduleRelationship_MIN =
    TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_MIN;
  static const ScheduleRelationship ScheduleRelationship_MAX =
    TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_MAX;
  static const int ScheduleRelationship_ARRAYSIZE =
    TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ScheduleRelationship_descriptor() {
    return TripUpdate_StopTimeUpdate_ScheduleRelationship_descriptor();
  }
  static inline const ::std::string& ScheduleRelationship_Name(ScheduleRelationship value) {
    return TripUpdate_StopTimeUpdate_ScheduleRelationship_Name(value);
  }
  static inline bool ScheduleRelationship_Parse(const ::std::string& name,
      ScheduleRelationship* value) {
    return TripUpdate_StopTimeUpdate_ScheduleRelationship_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional uint32 stop_sequence = 1;
  bool has_stop_sequence() const;
  void clear_stop_sequence();
  static const int kStopSequenceFieldNumber = 1;
  ::google::protobuf::uint32 stop_sequence() const;
  void set_stop_sequence(::google::protobuf::uint32 value);

  // optional string stop_id = 4;
  bool has_stop_id() const;
  void clear_stop_id();
  static const int kStopIdFieldNumber = 4;
  const ::std::string& stop_id() const;
  void set_stop_id(const ::std::string& value);
  void set_stop_id(const char* value);
  void set_stop_id(const char* value, size_t size);
  ::std::string* mutable_stop_id();
  ::std::string* release_stop_id();
  void set_allocated_stop_id(::std::string* stop_id);

  // optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;
  bool has_arrival() const;
  void clear_arrival();
  static const int kArrivalFieldNumber = 2;
  const ::transit_realtime::TripUpdate_StopTimeEvent& arrival() const;
  ::transit_realtime::TripUpdate_StopTimeEvent* mutable_arrival();
  ::transit_realtime::TripUpdate_StopTimeEvent* release_arrival();
  void set_allocated_arrival(::transit_realtime::TripUpdate_StopTimeEvent* arrival);

  // optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;
  bool has_departure() const;
  void clear_departure();
  static const int kDepartureFieldNumber = 3;
  const ::transit_realtime::TripUpdate_StopTimeEvent& departure() const;
  ::transit_realtime::TripUpdate_StopTimeEvent* mutable_departure();
  ::transit_realtime::TripUpdate_StopTimeEvent* release_departure();
  void set_allocated_departure(::transit_realtime::TripUpdate_StopTimeEvent* departure);

  // optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED];
  bool has_schedule_relationship() const;
  void clear_schedule_relationship();
  static const int kScheduleRelationshipFieldNumber = 5;
  ::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship schedule_relationship() const;
  void set_schedule_relationship(::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(TripUpdate_StopTimeUpdate)
  // @@protoc_insertion_point(class_scope:transit_realtime.TripUpdate.StopTimeUpdate)
 private:
  inline void set_has_stop_sequence();
  inline void clear_has_stop_sequence();
  inline void set_has_stop_id();
  inline void clear_has_stop_id();
  inline void set_has_arrival();
  inline void clear_has_arrival();
  inline void set_has_departure();
  inline void clear_has_departure();
  inline void set_has_schedule_relationship();
  inline void clear_has_schedule_relationship();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr stop_id_;
  ::transit_realtime::TripUpdate_StopTimeEvent* arrival_;
  ::google::protobuf::uint32 stop_sequence_;
  int schedule_relationship_;
  ::transit_realtime::TripUpdate_StopTimeEvent* departure_;
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();

  void InitAsDefaultInstance();
  static TripUpdate_StopTimeUpdate* default_instance_;
};
// -------------------------------------------------------------------

class TripUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:transit_realtime.TripUpdate) */ {
 public:
  TripUpdate();
  virtual ~TripUpdate();

  TripUpdate(const TripUpdate& from);

  inline TripUpdate& operator=(const TripUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TripUpdate& default_instance();

  void Swap(TripUpdate* other);

  // implements Message ----------------------------------------------

  inline TripUpdate* New() const { return New(NULL); }

  TripUpdate* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TripUpdate& from);
  void MergeFrom(const TripUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TripUpdate_StopTimeEvent StopTimeEvent;
  typedef TripUpdate_StopTimeUpdate StopTimeUpdate;

  // accessors -------------------------------------------------------

  // required .transit_realtime.TripDescriptor trip = 1;
  bool has_trip() const;
  void clear_trip();
  static const int kTripFieldNumber = 1;
  const ::transit_realtime::TripDescriptor& trip() const;
  ::transit_realtime::TripDescriptor* mutable_trip();
  ::transit_realtime::TripDescriptor* release_trip();
  void set_allocated_trip(::transit_realtime::TripDescriptor* trip);

  // optional .transit_realtime.VehicleDescriptor vehicle = 3;
  bool has_vehicle() const;
  void clear_vehicle();
  static const int kVehicleFieldNumber = 3;
  const ::transit_realtime::VehicleDescriptor& vehicle() const;
  ::transit_realtime::VehicleDescriptor* mutable_vehicle();
  ::transit_realtime::VehicleDescriptor* release_vehicle();
  void set_allocated_vehicle(::transit_realtime::VehicleDescriptor* vehicle);

  // repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;
  int stop_time_update_size() const;
  void clear_stop_time_update();
  static const int kStopTimeUpdateFieldNumber = 2;
  const ::transit_realtime::TripUpdate_StopTimeUpdate& stop_time_update(int index) const;
  ::transit_realtime::TripUpdate_StopTimeUpdate* mutable_stop_time_update(int index);
  ::transit_realtime::TripUpdate_StopTimeUpdate* add_stop_time_update();
  ::google::protobuf::RepeatedPtrField< ::transit_realtime::TripUpdate_StopTimeUpdate >*
      mutable_stop_time_update();
  const ::google::protobuf::RepeatedPtrField< ::transit_realtime::TripUpdate_StopTimeUpdate >&
      stop_time_update() const;

  // optional uint64 timestamp = 4;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(TripUpdate)
  // @@protoc_insertion_point(class_scope:transit_realtime.TripUpdate)
 private:
  inline void set_has_trip();
  inline void clear_has_trip();
  inline void set_has_vehicle();
  inline void clear_has_vehicle();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::transit_realtime::TripDescriptor* trip_;
  ::transit_realtime::VehicleDescriptor* vehicle_;
  ::google::protobuf::RepeatedPtrField< ::transit_realtime::TripUpdate_StopTimeUpdate > stop_time_update_;
  ::google::protobuf::uint64 timestamp_;
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();

  void InitAsDefaultInstance();
  static TripUpdate* default_instance_;
};
// -------------------------------------------------------------------

class VehiclePosition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:transit_realtime.VehiclePosition) */ {
 public:
  VehiclePosition();
  virtual ~VehiclePosition();

  VehiclePosition(const VehiclePosition& from);

  inline VehiclePosition& operator=(const VehiclePosition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VehiclePosition& default_instance();

  void Swap(VehiclePosition* other);

  // implements Message ----------------------------------------------

  inline VehiclePosition* New() const { return New(NULL); }

  VehiclePosition* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VehiclePosition& from);
  void MergeFrom(const VehiclePosition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VehiclePosition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef VehiclePosition_VehicleStopStatus VehicleStopStatus;
  static const VehicleStopStatus INCOMING_AT =
    VehiclePosition_VehicleStopStatus_INCOMING_AT;
  static const VehicleStopStatus STOPPED_AT =
    VehiclePosition_VehicleStopStatus_STOPPED_AT;
  static const VehicleStopStatus IN_TRANSIT_TO =
    VehiclePosition_VehicleStopStatus_IN_TRANSIT_TO;
  static inline bool VehicleStopStatus_IsValid(int value) {
    return VehiclePosition_VehicleStopStatus_IsValid(value);
  }
  static const VehicleStopStatus VehicleStopStatus_MIN =
    VehiclePosition_VehicleStopStatus_VehicleStopStatus_MIN;
  static const VehicleStopStatus VehicleStopStatus_MAX =
    VehiclePosition_VehicleStopStatus_VehicleStopStatus_MAX;
  static const int VehicleStopStatus_ARRAYSIZE =
    VehiclePosition_VehicleStopStatus_VehicleStopStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  VehicleStopStatus_descriptor() {
    return VehiclePosition_VehicleStopStatus_descriptor();
  }
  static inline const ::std::string& VehicleStopStatus_Name(VehicleStopStatus value) {
    return VehiclePosition_VehicleStopStatus_Name(value);
  }
  static inline bool VehicleStopStatus_Parse(const ::std::string& name,
      VehicleStopStatus* value) {
    return VehiclePosition_VehicleStopStatus_Parse(name, value);
  }

  typedef VehiclePosition_CongestionLevel CongestionLevel;
  static const CongestionLevel UNKNOWN_CONGESTION_LEVEL =
    VehiclePosition_CongestionLevel_UNKNOWN_CONGESTION_LEVEL;
  static const CongestionLevel RUNNING_SMOOTHLY =
    VehiclePosition_CongestionLevel_RUNNING_SMOOTHLY;
  static const CongestionLevel STOP_AND_GO =
    VehiclePosition_CongestionLevel_STOP_AND_GO;
  static const CongestionLevel CONGESTION =
    VehiclePosition_CongestionLevel_CONGESTION;
  static const CongestionLevel SEVERE_CONGESTION =
    VehiclePosition_CongestionLevel_SEVERE_CONGESTION;
  static inline bool CongestionLevel_IsValid(int value) {
    return VehiclePosition_CongestionLevel_IsValid(value);
  }
  static const CongestionLevel CongestionLevel_MIN =
    VehiclePosition_CongestionLevel_CongestionLevel_MIN;
  static const CongestionLevel CongestionLevel_MAX =
    VehiclePosition_CongestionLevel_CongestionLevel_MAX;
  static const int CongestionLevel_ARRAYSIZE =
    VehiclePosition_CongestionLevel_CongestionLevel_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CongestionLevel_descriptor() {
    return VehiclePosition_CongestionLevel_descriptor();
  }
  static inline const ::std::string& CongestionLevel_Name(CongestionLevel value) {
    return VehiclePosition_CongestionLevel_Name(value);
  }
  static inline bool CongestionLevel_Parse(const ::std::string& name,
      CongestionLevel* value) {
    return VehiclePosition_CongestionLevel_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .transit_realtime.TripDescriptor trip = 1;
  bool has_trip() const;
  void clear_trip();
  static const int kTripFieldNumber = 1;
  const ::transit_realtime::TripDescriptor& trip() const;
  ::transit_realtime::TripDescriptor* mutable_trip();
  ::transit_realtime::TripDescriptor* release_trip();
  void set_allocated_trip(::transit_realtime::TripDescriptor* trip);

  // optional .transit_realtime.VehicleDescriptor vehicle = 8;
  bool has_vehicle() const;
  void clear_vehicle();
  static const int kVehicleFieldNumber = 8;
  const ::transit_realtime::VehicleDescriptor& vehicle() const;
  ::transit_realtime::VehicleDescriptor* mutable_vehicle();
  ::transit_realtime::VehicleDescriptor* release_vehicle();
  void set_allocated_vehicle(::transit_realtime::VehicleDescriptor* vehicle);

  // optional .transit_realtime.Position position = 2;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 2;
  const ::transit_realtime::Position& position() const;
  ::transit_realtime::Position* mutable_position();
  ::transit_realtime::Position* release_position();
  void set_allocated_position(::transit_realtime::Position* position);

  // optional uint32 current_stop_sequence = 3;
  bool has_current_stop_sequence() const;
  void clear_current_stop_sequence();
  static const int kCurrentStopSequenceFieldNumber = 3;
  ::google::protobuf::uint32 current_stop_sequence() const;
  void set_current_stop_sequence(::google::protobuf::uint32 value);

  // optional string stop_id = 7;
  bool has_stop_id() const;
  void clear_stop_id();
  static const int kStopIdFieldNumber = 7;
  const ::std::string& stop_id() const;
  void set_stop_id(const ::std::string& value);
  void set_stop_id(const char* value);
  void set_stop_id(const char* value, size_t size);
  ::std::string* mutable_stop_id();
  ::std::string* release_stop_id();
  void set_allocated_stop_id(::std::string* stop_id);

  // optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];
  bool has_current_status() const;
  void clear_current_status();
  static const int kCurrentStatusFieldNumber = 4;
  ::transit_realtime::VehiclePosition_VehicleStopStatus current_status() const;
  void set_current_status(::transit_realtime::VehiclePosition_VehicleStopStatus value);

  // optional uint64 timestamp = 5;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;
  bool has_congestion_level() const;
  void clear_congestion_level();
  static const int kCongestionLevelFieldNumber = 6;
  ::transit_realtime::VehiclePosition_CongestionLevel congestion_level() const;
  void set_congestion_level(::transit_realtime::VehiclePosition_CongestionLevel value);

  // optional .transit_realtime.OVapiVehiclePosition ovapi_vehicle_position = 1003;
  bool has_ovapi_vehicle_position() const;
  void clear_ovapi_vehicle_position();
  static const int kOvapiVehiclePositionFieldNumber = 1003;
  const ::transit_realtime::OVapiVehiclePosition& ovapi_vehicle_position() const;
  ::transit_realtime::OVapiVehiclePosition* mutable_ovapi_vehicle_position();
  ::transit_realtime::OVapiVehiclePosition* release_ovapi_vehicle_position();
  void set_allocated_ovapi_vehicle_position(::transit_realtime::OVapiVehiclePosition* ovapi_vehicle_position);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(VehiclePosition)
  // @@protoc_insertion_point(class_scope:transit_realtime.VehiclePosition)
 private:
  inline void set_has_trip();
  inline void clear_has_trip();
  inline void set_has_vehicle();
  inline void clear_has_vehicle();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_current_stop_sequence();
  inline void clear_has_current_stop_sequence();
  inline void set_has_stop_id();
  inline void clear_has_stop_id();
  inline void set_has_current_status();
  inline void clear_has_current_status();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_congestion_level();
  inline void clear_has_congestion_level();
  inline void set_has_ovapi_vehicle_position();
  inline void clear_has_ovapi_vehicle_position();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::transit_realtime::TripDescriptor* trip_;
  ::transit_realtime::VehicleDescriptor* vehicle_;
  ::transit_realtime::Position* position_;
  ::google::protobuf::internal::ArenaStringPtr stop_id_;
  ::google::protobuf::uint32 current_stop_sequence_;
  int current_status_;
  ::google::protobuf::uint64 timestamp_;
  ::transit_realtime::OVapiVehiclePosition* ovapi_vehicle_position_;
  int congestion_level_;
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();

  void InitAsDefaultInstance();
  static VehiclePosition* default_instance_;
};
// -------------------------------------------------------------------

class OVapiVehiclePosition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:transit_realtime.OVapiVehiclePosition) */ {
 public:
  OVapiVehiclePosition();
  virtual ~OVapiVehiclePosition();

  OVapiVehiclePosition(const OVapiVehiclePosition& from);

  inline OVapiVehiclePosition& operator=(const OVapiVehiclePosition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OVapiVehiclePosition& default_instance();

  void Swap(OVapiVehiclePosition* other);

  // implements Message ----------------------------------------------

  inline OVapiVehiclePosition* New() const { return New(NULL); }

  OVapiVehiclePosition* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OVapiVehiclePosition& from);
  void MergeFrom(const OVapiVehiclePosition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OVapiVehiclePosition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 delay = 1;
  bool has_delay() const;
  void clear_delay();
  static const int kDelayFieldNumber = 1;
  ::google::protobuf::int32 delay() const;
  void set_delay(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:transit_realtime.OVapiVehiclePosition)
 private:
  inline void set_has_delay();
  inline void clear_has_delay();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 delay_;
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();

  void InitAsDefaultInstance();
  static OVapiVehiclePosition* default_instance_;
};
// -------------------------------------------------------------------

class Alert : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:transit_realtime.Alert) */ {
 public:
  Alert();
  virtual ~Alert();

  Alert(const Alert& from);

  inline Alert& operator=(const Alert& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Alert& default_instance();

  void Swap(Alert* other);

  // implements Message ----------------------------------------------

  inline Alert* New() const { return New(NULL); }

  Alert* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Alert& from);
  void MergeFrom(const Alert& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Alert* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Alert_Cause Cause;
  static const Cause UNKNOWN_CAUSE =
    Alert_Cause_UNKNOWN_CAUSE;
  static const Cause OTHER_CAUSE =
    Alert_Cause_OTHER_CAUSE;
  static const Cause TECHNICAL_PROBLEM =
    Alert_Cause_TECHNICAL_PROBLEM;
  static const Cause STRIKE =
    Alert_Cause_STRIKE;
  static const Cause DEMONSTRATION =
    Alert_Cause_DEMONSTRATION;
  static const Cause ACCIDENT =
    Alert_Cause_ACCIDENT;
  static const Cause HOLIDAY =
    Alert_Cause_HOLIDAY;
  static const Cause WEATHER =
    Alert_Cause_WEATHER;
  static const Cause MAINTENANCE =
    Alert_Cause_MAINTENANCE;
  static const Cause CONSTRUCTION =
    Alert_Cause_CONSTRUCTION;
  static const Cause POLICE_ACTIVITY =
    Alert_Cause_POLICE_ACTIVITY;
  static const Cause MEDICAL_EMERGENCY =
    Alert_Cause_MEDICAL_EMERGENCY;
  static inline bool Cause_IsValid(int value) {
    return Alert_Cause_IsValid(value);
  }
  static const Cause Cause_MIN =
    Alert_Cause_Cause_MIN;
  static const Cause Cause_MAX =
    Alert_Cause_Cause_MAX;
  static const int Cause_ARRAYSIZE =
    Alert_Cause_Cause_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Cause_descriptor() {
    return Alert_Cause_descriptor();
  }
  static inline const ::std::string& Cause_Name(Cause value) {
    return Alert_Cause_Name(value);
  }
  static inline bool Cause_Parse(const ::std::string& name,
      Cause* value) {
    return Alert_Cause_Parse(name, value);
  }

  typedef Alert_Effect Effect;
  static const Effect NO_SERVICE =
    Alert_Effect_NO_SERVICE;
  static const Effect REDUCED_SERVICE =
    Alert_Effect_REDUCED_SERVICE;
  static const Effect SIGNIFICANT_DELAYS =
    Alert_Effect_SIGNIFICANT_DELAYS;
  static const Effect DETOUR =
    Alert_Effect_DETOUR;
  static const Effect ADDITIONAL_SERVICE =
    Alert_Effect_ADDITIONAL_SERVICE;
  static const Effect MODIFIED_SERVICE =
    Alert_Effect_MODIFIED_SERVICE;
  static const Effect OTHER_EFFECT =
    Alert_Effect_OTHER_EFFECT;
  static const Effect UNKNOWN_EFFECT =
    Alert_Effect_UNKNOWN_EFFECT;
  static const Effect STOP_MOVED =
    Alert_Effect_STOP_MOVED;
  static inline bool Effect_IsValid(int value) {
    return Alert_Effect_IsValid(value);
  }
  static const Effect Effect_MIN =
    Alert_Effect_Effect_MIN;
  static const Effect Effect_MAX =
    Alert_Effect_Effect_MAX;
  static const int Effect_ARRAYSIZE =
    Alert_Effect_Effect_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Effect_descriptor() {
    return Alert_Effect_descriptor();
  }
  static inline const ::std::string& Effect_Name(Effect value) {
    return Alert_Effect_Name(value);
  }
  static inline bool Effect_Parse(const ::std::string& name,
      Effect* value) {
    return Alert_Effect_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .transit_realtime.TimeRange active_period = 1;
  int active_period_size() const;
  void clear_active_period();
  static const int kActivePeriodFieldNumber = 1;
  const ::transit_realtime::TimeRange& active_period(int index) const;
  ::transit_realtime::TimeRange* mutable_active_period(int index);
  ::transit_realtime::TimeRange* add_active_period();
  ::google::protobuf::RepeatedPtrField< ::transit_realtime::TimeRange >*
      mutable_active_period();
  const ::google::protobuf::RepeatedPtrField< ::transit_realtime::TimeRange >&
      active_period() const;

  // repeated .transit_realtime.EntitySelector informed_entity = 5;
  int informed_entity_size() const;
  void clear_informed_entity();
  static const int kInformedEntityFieldNumber = 5;
  const ::transit_realtime::EntitySelector& informed_entity(int index) const;
  ::transit_realtime::EntitySelector* mutable_informed_entity(int index);
  ::transit_realtime::EntitySelector* add_informed_entity();
  ::google::protobuf::RepeatedPtrField< ::transit_realtime::EntitySelector >*
      mutable_informed_entity();
  const ::google::protobuf::RepeatedPtrField< ::transit_realtime::EntitySelector >&
      informed_entity() const;

  // optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE];
  bool has_cause() const;
  void clear_cause();
  static const int kCauseFieldNumber = 6;
  ::transit_realtime::Alert_Cause cause() const;
  void set_cause(::transit_realtime::Alert_Cause value);

  // optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT];
  bool has_effect() const;
  void clear_effect();
  static const int kEffectFieldNumber = 7;
  ::transit_realtime::Alert_Effect effect() const;
  void set_effect(::transit_realtime::Alert_Effect value);

  // optional .transit_realtime.TranslatedString url = 8;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 8;
  const ::transit_realtime::TranslatedString& url() const;
  ::transit_realtime::TranslatedString* mutable_url();
  ::transit_realtime::TranslatedString* release_url();
  void set_allocated_url(::transit_realtime::TranslatedString* url);

  // optional .transit_realtime.TranslatedString header_text = 10;
  bool has_header_text() const;
  void clear_header_text();
  static const int kHeaderTextFieldNumber = 10;
  const ::transit_realtime::TranslatedString& header_text() const;
  ::transit_realtime::TranslatedString* mutable_header_text();
  ::transit_realtime::TranslatedString* release_header_text();
  void set_allocated_header_text(::transit_realtime::TranslatedString* header_text);

  // optional .transit_realtime.TranslatedString description_text = 11;
  bool has_description_text() const;
  void clear_description_text();
  static const int kDescriptionTextFieldNumber = 11;
  const ::transit_realtime::TranslatedString& description_text() const;
  ::transit_realtime::TranslatedString* mutable_description_text();
  ::transit_realtime::TranslatedString* release_description_text();
  void set_allocated_description_text(::transit_realtime::TranslatedString* description_text);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Alert)
  // @@protoc_insertion_point(class_scope:transit_realtime.Alert)
 private:
  inline void set_has_cause();
  inline void clear_has_cause();
  inline void set_has_effect();
  inline void clear_has_effect();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_header_text();
  inline void clear_has_header_text();
  inline void set_has_description_text();
  inline void clear_has_description_text();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::transit_realtime::TimeRange > active_period_;
  ::google::protobuf::RepeatedPtrField< ::transit_realtime::EntitySelector > informed_entity_;
  int cause_;
  int effect_;
  ::transit_realtime::TranslatedString* url_;
  ::transit_realtime::TranslatedString* header_text_;
  ::transit_realtime::TranslatedString* description_text_;
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();

  void InitAsDefaultInstance();
  static Alert* default_instance_;
};
// -------------------------------------------------------------------

class TimeRange : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:transit_realtime.TimeRange) */ {
 public:
  TimeRange();
  virtual ~TimeRange();

  TimeRange(const TimeRange& from);

  inline TimeRange& operator=(const TimeRange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimeRange& default_instance();

  void Swap(TimeRange* other);

  // implements Message ----------------------------------------------

  inline TimeRange* New() const { return New(NULL); }

  TimeRange* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimeRange& from);
  void MergeFrom(const TimeRange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TimeRange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 start = 1;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 1;
  ::google::protobuf::uint64 start() const;
  void set_start(::google::protobuf::uint64 value);

  // optional uint64 end = 2;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 2;
  ::google::protobuf::uint64 end() const;
  void set_end(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:transit_realtime.TimeRange)
 private:
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_end();
  inline void clear_has_end();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 start_;
  ::google::protobuf::uint64 end_;
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();

  void InitAsDefaultInstance();
  static TimeRange* default_instance_;
};
// -------------------------------------------------------------------

class Position : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:transit_realtime.Position) */ {
 public:
  Position();
  virtual ~Position();

  Position(const Position& from);

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Position& default_instance();

  void Swap(Position* other);

  // implements Message ----------------------------------------------

  inline Position* New() const { return New(NULL); }

  Position* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Position* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float latitude = 1;
  bool has_latitude() const;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 1;
  float latitude() const;
  void set_latitude(float value);

  // required float longitude = 2;
  bool has_longitude() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 2;
  float longitude() const;
  void set_longitude(float value);

  // optional float bearing = 3;
  bool has_bearing() const;
  void clear_bearing();
  static const int kBearingFieldNumber = 3;
  float bearing() const;
  void set_bearing(float value);

  // optional double odometer = 4;
  bool has_odometer() const;
  void clear_odometer();
  static const int kOdometerFieldNumber = 4;
  double odometer() const;
  void set_odometer(double value);

  // optional float speed = 5;
  bool has_speed() const;
  void clear_speed();
  static const int kSpeedFieldNumber = 5;
  float speed() const;
  void set_speed(float value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Position)
  // @@protoc_insertion_point(class_scope:transit_realtime.Position)
 private:
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_bearing();
  inline void clear_has_bearing();
  inline void set_has_odometer();
  inline void clear_has_odometer();
  inline void set_has_speed();
  inline void clear_has_speed();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float latitude_;
  float longitude_;
  double odometer_;
  float bearing_;
  float speed_;
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();

  void InitAsDefaultInstance();
  static Position* default_instance_;
};
// -------------------------------------------------------------------

class TripDescriptor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:transit_realtime.TripDescriptor) */ {
 public:
  TripDescriptor();
  virtual ~TripDescriptor();

  TripDescriptor(const TripDescriptor& from);

  inline TripDescriptor& operator=(const TripDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TripDescriptor& default_instance();

  void Swap(TripDescriptor* other);

  // implements Message ----------------------------------------------

  inline TripDescriptor* New() const { return New(NULL); }

  TripDescriptor* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TripDescriptor& from);
  void MergeFrom(const TripDescriptor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TripDescriptor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TripDescriptor_ScheduleRelationship ScheduleRelationship;
  static const ScheduleRelationship SCHEDULED =
    TripDescriptor_ScheduleRelationship_SCHEDULED;
  static const ScheduleRelationship ADDED =
    TripDescriptor_ScheduleRelationship_ADDED;
  static const ScheduleRelationship UNSCHEDULED =
    TripDescriptor_ScheduleRelationship_UNSCHEDULED;
  static const ScheduleRelationship CANCELED =
    TripDescriptor_ScheduleRelationship_CANCELED;
  static const ScheduleRelationship REPLACEMENT =
    TripDescriptor_ScheduleRelationship_REPLACEMENT;
  static inline bool ScheduleRelationship_IsValid(int value) {
    return TripDescriptor_ScheduleRelationship_IsValid(value);
  }
  static const ScheduleRelationship ScheduleRelationship_MIN =
    TripDescriptor_ScheduleRelationship_ScheduleRelationship_MIN;
  static const ScheduleRelationship ScheduleRelationship_MAX =
    TripDescriptor_ScheduleRelationship_ScheduleRelationship_MAX;
  static const int ScheduleRelationship_ARRAYSIZE =
    TripDescriptor_ScheduleRelationship_ScheduleRelationship_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ScheduleRelationship_descriptor() {
    return TripDescriptor_ScheduleRelationship_descriptor();
  }
  static inline const ::std::string& ScheduleRelationship_Name(ScheduleRelationship value) {
    return TripDescriptor_ScheduleRelationship_Name(value);
  }
  static inline bool ScheduleRelationship_Parse(const ::std::string& name,
      ScheduleRelationship* value) {
    return TripDescriptor_ScheduleRelationship_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string trip_id = 1;
  bool has_trip_id() const;
  void clear_trip_id();
  static const int kTripIdFieldNumber = 1;
  const ::std::string& trip_id() const;
  void set_trip_id(const ::std::string& value);
  void set_trip_id(const char* value);
  void set_trip_id(const char* value, size_t size);
  ::std::string* mutable_trip_id();
  ::std::string* release_trip_id();
  void set_allocated_trip_id(::std::string* trip_id);

  // optional string route_id = 5;
  bool has_route_id() const;
  void clear_route_id();
  static const int kRouteIdFieldNumber = 5;
  const ::std::string& route_id() const;
  void set_route_id(const ::std::string& value);
  void set_route_id(const char* value);
  void set_route_id(const char* value, size_t size);
  ::std::string* mutable_route_id();
  ::std::string* release_route_id();
  void set_allocated_route_id(::std::string* route_id);

  // optional string start_time = 2;
  bool has_start_time() const;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 2;
  const ::std::string& start_time() const;
  void set_start_time(const ::std::string& value);
  void set_start_time(const char* value);
  void set_start_time(const char* value, size_t size);
  ::std::string* mutable_start_time();
  ::std::string* release_start_time();
  void set_allocated_start_time(::std::string* start_time);

  // optional string start_date = 3;
  bool has_start_date() const;
  void clear_start_date();
  static const int kStartDateFieldNumber = 3;
  const ::std::string& start_date() const;
  void set_start_date(const ::std::string& value);
  void set_start_date(const char* value);
  void set_start_date(const char* value, size_t size);
  ::std::string* mutable_start_date();
  ::std::string* release_start_date();
  void set_allocated_start_date(::std::string* start_date);

  // optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;
  bool has_schedule_relationship() const;
  void clear_schedule_relationship();
  static const int kScheduleRelationshipFieldNumber = 4;
  ::transit_realtime::TripDescriptor_ScheduleRelationship schedule_relationship() const;
  void set_schedule_relationship(::transit_realtime::TripDescriptor_ScheduleRelationship value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(TripDescriptor)
  // @@protoc_insertion_point(class_scope:transit_realtime.TripDescriptor)
 private:
  inline void set_has_trip_id();
  inline void clear_has_trip_id();
  inline void set_has_route_id();
  inline void clear_has_route_id();
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_start_date();
  inline void clear_has_start_date();
  inline void set_has_schedule_relationship();
  inline void clear_has_schedule_relationship();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr trip_id_;
  ::google::protobuf::internal::ArenaStringPtr route_id_;
  ::google::protobuf::internal::ArenaStringPtr start_time_;
  ::google::protobuf::internal::ArenaStringPtr start_date_;
  int schedule_relationship_;
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();

  void InitAsDefaultInstance();
  static TripDescriptor* default_instance_;
};
// -------------------------------------------------------------------

class VehicleDescriptor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:transit_realtime.VehicleDescriptor) */ {
 public:
  VehicleDescriptor();
  virtual ~VehicleDescriptor();

  VehicleDescriptor(const VehicleDescriptor& from);

  inline VehicleDescriptor& operator=(const VehicleDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleDescriptor& default_instance();

  void Swap(VehicleDescriptor* other);

  // implements Message ----------------------------------------------

  inline VehicleDescriptor* New() const { return New(NULL); }

  VehicleDescriptor* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VehicleDescriptor& from);
  void MergeFrom(const VehicleDescriptor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VehicleDescriptor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional string label = 2;
  bool has_label() const;
  void clear_label();
  static const int kLabelFieldNumber = 2;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // optional string license_plate = 3;
  bool has_license_plate() const;
  void clear_license_plate();
  static const int kLicensePlateFieldNumber = 3;
  const ::std::string& license_plate() const;
  void set_license_plate(const ::std::string& value);
  void set_license_plate(const char* value);
  void set_license_plate(const char* value, size_t size);
  ::std::string* mutable_license_plate();
  ::std::string* release_license_plate();
  void set_allocated_license_plate(::std::string* license_plate);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(VehicleDescriptor)
  // @@protoc_insertion_point(class_scope:transit_realtime.VehicleDescriptor)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_license_plate();
  inline void clear_has_license_plate();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::google::protobuf::internal::ArenaStringPtr license_plate_;
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();

  void InitAsDefaultInstance();
  static VehicleDescriptor* default_instance_;
};
// -------------------------------------------------------------------

class EntitySelector : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:transit_realtime.EntitySelector) */ {
 public:
  EntitySelector();
  virtual ~EntitySelector();

  EntitySelector(const EntitySelector& from);

  inline EntitySelector& operator=(const EntitySelector& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EntitySelector& default_instance();

  void Swap(EntitySelector* other);

  // implements Message ----------------------------------------------

  inline EntitySelector* New() const { return New(NULL); }

  EntitySelector* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EntitySelector& from);
  void MergeFrom(const EntitySelector& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EntitySelector* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string agency_id = 1;
  bool has_agency_id() const;
  void clear_agency_id();
  static const int kAgencyIdFieldNumber = 1;
  const ::std::string& agency_id() const;
  void set_agency_id(const ::std::string& value);
  void set_agency_id(const char* value);
  void set_agency_id(const char* value, size_t size);
  ::std::string* mutable_agency_id();
  ::std::string* release_agency_id();
  void set_allocated_agency_id(::std::string* agency_id);

  // optional string route_id = 2;
  bool has_route_id() const;
  void clear_route_id();
  static const int kRouteIdFieldNumber = 2;
  const ::std::string& route_id() const;
  void set_route_id(const ::std::string& value);
  void set_route_id(const char* value);
  void set_route_id(const char* value, size_t size);
  ::std::string* mutable_route_id();
  ::std::string* release_route_id();
  void set_allocated_route_id(::std::string* route_id);

  // optional int32 route_type = 3;
  bool has_route_type() const;
  void clear_route_type();
  static const int kRouteTypeFieldNumber = 3;
  ::google::protobuf::int32 route_type() const;
  void set_route_type(::google::protobuf::int32 value);

  // optional .transit_realtime.TripDescriptor trip = 4;
  bool has_trip() const;
  void clear_trip();
  static const int kTripFieldNumber = 4;
  const ::transit_realtime::TripDescriptor& trip() const;
  ::transit_realtime::TripDescriptor* mutable_trip();
  ::transit_realtime::TripDescriptor* release_trip();
  void set_allocated_trip(::transit_realtime::TripDescriptor* trip);

  // optional string stop_id = 5;
  bool has_stop_id() const;
  void clear_stop_id();
  static const int kStopIdFieldNumber = 5;
  const ::std::string& stop_id() const;
  void set_stop_id(const ::std::string& value);
  void set_stop_id(const char* value);
  void set_stop_id(const char* value, size_t size);
  ::std::string* mutable_stop_id();
  ::std::string* release_stop_id();
  void set_allocated_stop_id(::std::string* stop_id);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(EntitySelector)
  // @@protoc_insertion_point(class_scope:transit_realtime.EntitySelector)
 private:
  inline void set_has_agency_id();
  inline void clear_has_agency_id();
  inline void set_has_route_id();
  inline void clear_has_route_id();
  inline void set_has_route_type();
  inline void clear_has_route_type();
  inline void set_has_trip();
  inline void clear_has_trip();
  inline void set_has_stop_id();
  inline void clear_has_stop_id();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr agency_id_;
  ::google::protobuf::internal::ArenaStringPtr route_id_;
  ::transit_realtime::TripDescriptor* trip_;
  ::google::protobuf::internal::ArenaStringPtr stop_id_;
  ::google::protobuf::int32 route_type_;
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();

  void InitAsDefaultInstance();
  static EntitySelector* default_instance_;
};
// -------------------------------------------------------------------

class TranslatedString_Translation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:transit_realtime.TranslatedString.Translation) */ {
 public:
  TranslatedString_Translation();
  virtual ~TranslatedString_Translation();

  TranslatedString_Translation(const TranslatedString_Translation& from);

  inline TranslatedString_Translation& operator=(const TranslatedString_Translation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TranslatedString_Translation& default_instance();

  void Swap(TranslatedString_Translation* other);

  // implements Message ----------------------------------------------

  inline TranslatedString_Translation* New() const { return New(NULL); }

  TranslatedString_Translation* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TranslatedString_Translation& from);
  void MergeFrom(const TranslatedString_Translation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TranslatedString_Translation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string text = 1;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // optional string language = 2;
  bool has_language() const;
  void clear_language();
  static const int kLanguageFieldNumber = 2;
  const ::std::string& language() const;
  void set_language(const ::std::string& value);
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  ::std::string* mutable_language();
  ::std::string* release_language();
  void set_allocated_language(::std::string* language);

  // @@protoc_insertion_point(class_scope:transit_realtime.TranslatedString.Translation)
 private:
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_language();
  inline void clear_has_language();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::internal::ArenaStringPtr language_;
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();

  void InitAsDefaultInstance();
  static TranslatedString_Translation* default_instance_;
};
// -------------------------------------------------------------------

class TranslatedString : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:transit_realtime.TranslatedString) */ {
 public:
  TranslatedString();
  virtual ~TranslatedString();

  TranslatedString(const TranslatedString& from);

  inline TranslatedString& operator=(const TranslatedString& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TranslatedString& default_instance();

  void Swap(TranslatedString* other);

  // implements Message ----------------------------------------------

  inline TranslatedString* New() const { return New(NULL); }

  TranslatedString* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TranslatedString& from);
  void MergeFrom(const TranslatedString& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TranslatedString* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TranslatedString_Translation Translation;

  // accessors -------------------------------------------------------

  // repeated .transit_realtime.TranslatedString.Translation translation = 1;
  int translation_size() const;
  void clear_translation();
  static const int kTranslationFieldNumber = 1;
  const ::transit_realtime::TranslatedString_Translation& translation(int index) const;
  ::transit_realtime::TranslatedString_Translation* mutable_translation(int index);
  ::transit_realtime::TranslatedString_Translation* add_translation();
  ::google::protobuf::RepeatedPtrField< ::transit_realtime::TranslatedString_Translation >*
      mutable_translation();
  const ::google::protobuf::RepeatedPtrField< ::transit_realtime::TranslatedString_Translation >&
      translation() const;

  // @@protoc_insertion_point(class_scope:transit_realtime.TranslatedString)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::transit_realtime::TranslatedString_Translation > translation_;
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();

  void InitAsDefaultInstance();
  static TranslatedString* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// FeedMessage

// required .transit_realtime.FeedHeader header = 1;
inline bool FeedMessage::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FeedMessage::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FeedMessage::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FeedMessage::clear_header() {
  if (header_ != NULL) header_->::transit_realtime::FeedHeader::Clear();
  clear_has_header();
}
inline const ::transit_realtime::FeedHeader& FeedMessage::header() const {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedMessage.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::transit_realtime::FeedHeader* FeedMessage::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    header_ = new ::transit_realtime::FeedHeader;
  }
  // @@protoc_insertion_point(field_mutable:transit_realtime.FeedMessage.header)
  return header_;
}
inline ::transit_realtime::FeedHeader* FeedMessage::release_header() {
  // @@protoc_insertion_point(field_release:transit_realtime.FeedMessage.header)
  clear_has_header();
  ::transit_realtime::FeedHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void FeedMessage::set_allocated_header(::transit_realtime::FeedHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.FeedMessage.header)
}

// repeated .transit_realtime.FeedEntity entity = 2;
inline int FeedMessage::entity_size() const {
  return entity_.size();
}
inline void FeedMessage::clear_entity() {
  entity_.Clear();
}
inline const ::transit_realtime::FeedEntity& FeedMessage::entity(int index) const {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedMessage.entity)
  return entity_.Get(index);
}
inline ::transit_realtime::FeedEntity* FeedMessage::mutable_entity(int index) {
  // @@protoc_insertion_point(field_mutable:transit_realtime.FeedMessage.entity)
  return entity_.Mutable(index);
}
inline ::transit_realtime::FeedEntity* FeedMessage::add_entity() {
  // @@protoc_insertion_point(field_add:transit_realtime.FeedMessage.entity)
  return entity_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::transit_realtime::FeedEntity >*
FeedMessage::mutable_entity() {
  // @@protoc_insertion_point(field_mutable_list:transit_realtime.FeedMessage.entity)
  return &entity_;
}
inline const ::google::protobuf::RepeatedPtrField< ::transit_realtime::FeedEntity >&
FeedMessage::entity() const {
  // @@protoc_insertion_point(field_list:transit_realtime.FeedMessage.entity)
  return entity_;
}

// -------------------------------------------------------------------

// FeedHeader

// required string gtfs_realtime_version = 1;
inline bool FeedHeader::has_gtfs_realtime_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FeedHeader::set_has_gtfs_realtime_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FeedHeader::clear_has_gtfs_realtime_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FeedHeader::clear_gtfs_realtime_version() {
  gtfs_realtime_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_gtfs_realtime_version();
}
inline const ::std::string& FeedHeader::gtfs_realtime_version() const {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedHeader.gtfs_realtime_version)
  return gtfs_realtime_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FeedHeader::set_gtfs_realtime_version(const ::std::string& value) {
  set_has_gtfs_realtime_version();
  gtfs_realtime_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transit_realtime.FeedHeader.gtfs_realtime_version)
}
inline void FeedHeader::set_gtfs_realtime_version(const char* value) {
  set_has_gtfs_realtime_version();
  gtfs_realtime_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transit_realtime.FeedHeader.gtfs_realtime_version)
}
inline void FeedHeader::set_gtfs_realtime_version(const char* value, size_t size) {
  set_has_gtfs_realtime_version();
  gtfs_realtime_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transit_realtime.FeedHeader.gtfs_realtime_version)
}
inline ::std::string* FeedHeader::mutable_gtfs_realtime_version() {
  set_has_gtfs_realtime_version();
  // @@protoc_insertion_point(field_mutable:transit_realtime.FeedHeader.gtfs_realtime_version)
  return gtfs_realtime_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FeedHeader::release_gtfs_realtime_version() {
  // @@protoc_insertion_point(field_release:transit_realtime.FeedHeader.gtfs_realtime_version)
  clear_has_gtfs_realtime_version();
  return gtfs_realtime_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FeedHeader::set_allocated_gtfs_realtime_version(::std::string* gtfs_realtime_version) {
  if (gtfs_realtime_version != NULL) {
    set_has_gtfs_realtime_version();
  } else {
    clear_has_gtfs_realtime_version();
  }
  gtfs_realtime_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gtfs_realtime_version);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.FeedHeader.gtfs_realtime_version)
}

// optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET];
inline bool FeedHeader::has_incrementality() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FeedHeader::set_has_incrementality() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FeedHeader::clear_has_incrementality() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FeedHeader::clear_incrementality() {
  incrementality_ = 0;
  clear_has_incrementality();
}
inline ::transit_realtime::FeedHeader_Incrementality FeedHeader::incrementality() const {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedHeader.incrementality)
  return static_cast< ::transit_realtime::FeedHeader_Incrementality >(incrementality_);
}
inline void FeedHeader::set_incrementality(::transit_realtime::FeedHeader_Incrementality value) {
  assert(::transit_realtime::FeedHeader_Incrementality_IsValid(value));
  set_has_incrementality();
  incrementality_ = value;
  // @@protoc_insertion_point(field_set:transit_realtime.FeedHeader.incrementality)
}

// optional uint64 timestamp = 3;
inline bool FeedHeader::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FeedHeader::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FeedHeader::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FeedHeader::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 FeedHeader::timestamp() const {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedHeader.timestamp)
  return timestamp_;
}
inline void FeedHeader::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:transit_realtime.FeedHeader.timestamp)
}

// -------------------------------------------------------------------

// FeedEntity

// required string id = 1;
inline bool FeedEntity::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FeedEntity::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FeedEntity::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FeedEntity::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& FeedEntity::id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedEntity.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FeedEntity::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transit_realtime.FeedEntity.id)
}
inline void FeedEntity::set_id(const char* value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transit_realtime.FeedEntity.id)
}
inline void FeedEntity::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transit_realtime.FeedEntity.id)
}
inline ::std::string* FeedEntity::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.FeedEntity.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FeedEntity::release_id() {
  // @@protoc_insertion_point(field_release:transit_realtime.FeedEntity.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FeedEntity::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.FeedEntity.id)
}

// optional bool is_deleted = 2 [default = false];
inline bool FeedEntity::has_is_deleted() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FeedEntity::set_has_is_deleted() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FeedEntity::clear_has_is_deleted() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FeedEntity::clear_is_deleted() {
  is_deleted_ = false;
  clear_has_is_deleted();
}
inline bool FeedEntity::is_deleted() const {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedEntity.is_deleted)
  return is_deleted_;
}
inline void FeedEntity::set_is_deleted(bool value) {
  set_has_is_deleted();
  is_deleted_ = value;
  // @@protoc_insertion_point(field_set:transit_realtime.FeedEntity.is_deleted)
}

// optional .transit_realtime.TripUpdate trip_update = 3;
inline bool FeedEntity::has_trip_update() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FeedEntity::set_has_trip_update() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FeedEntity::clear_has_trip_update() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FeedEntity::clear_trip_update() {
  if (trip_update_ != NULL) trip_update_->::transit_realtime::TripUpdate::Clear();
  clear_has_trip_update();
}
inline const ::transit_realtime::TripUpdate& FeedEntity::trip_update() const {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedEntity.trip_update)
  return trip_update_ != NULL ? *trip_update_ : *default_instance_->trip_update_;
}
inline ::transit_realtime::TripUpdate* FeedEntity::mutable_trip_update() {
  set_has_trip_update();
  if (trip_update_ == NULL) {
    trip_update_ = new ::transit_realtime::TripUpdate;
  }
  // @@protoc_insertion_point(field_mutable:transit_realtime.FeedEntity.trip_update)
  return trip_update_;
}
inline ::transit_realtime::TripUpdate* FeedEntity::release_trip_update() {
  // @@protoc_insertion_point(field_release:transit_realtime.FeedEntity.trip_update)
  clear_has_trip_update();
  ::transit_realtime::TripUpdate* temp = trip_update_;
  trip_update_ = NULL;
  return temp;
}
inline void FeedEntity::set_allocated_trip_update(::transit_realtime::TripUpdate* trip_update) {
  delete trip_update_;
  trip_update_ = trip_update;
  if (trip_update) {
    set_has_trip_update();
  } else {
    clear_has_trip_update();
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.FeedEntity.trip_update)
}

// optional .transit_realtime.VehiclePosition vehicle = 4;
inline bool FeedEntity::has_vehicle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FeedEntity::set_has_vehicle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FeedEntity::clear_has_vehicle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FeedEntity::clear_vehicle() {
  if (vehicle_ != NULL) vehicle_->::transit_realtime::VehiclePosition::Clear();
  clear_has_vehicle();
}
inline const ::transit_realtime::VehiclePosition& FeedEntity::vehicle() const {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedEntity.vehicle)
  return vehicle_ != NULL ? *vehicle_ : *default_instance_->vehicle_;
}
inline ::transit_realtime::VehiclePosition* FeedEntity::mutable_vehicle() {
  set_has_vehicle();
  if (vehicle_ == NULL) {
    vehicle_ = new ::transit_realtime::VehiclePosition;
  }
  // @@protoc_insertion_point(field_mutable:transit_realtime.FeedEntity.vehicle)
  return vehicle_;
}
inline ::transit_realtime::VehiclePosition* FeedEntity::release_vehicle() {
  // @@protoc_insertion_point(field_release:transit_realtime.FeedEntity.vehicle)
  clear_has_vehicle();
  ::transit_realtime::VehiclePosition* temp = vehicle_;
  vehicle_ = NULL;
  return temp;
}
inline void FeedEntity::set_allocated_vehicle(::transit_realtime::VehiclePosition* vehicle) {
  delete vehicle_;
  vehicle_ = vehicle;
  if (vehicle) {
    set_has_vehicle();
  } else {
    clear_has_vehicle();
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.FeedEntity.vehicle)
}

// optional .transit_realtime.Alert alert = 5;
inline bool FeedEntity::has_alert() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FeedEntity::set_has_alert() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FeedEntity::clear_has_alert() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FeedEntity::clear_alert() {
  if (alert_ != NULL) alert_->::transit_realtime::Alert::Clear();
  clear_has_alert();
}
inline const ::transit_realtime::Alert& FeedEntity::alert() const {
  // @@protoc_insertion_point(field_get:transit_realtime.FeedEntity.alert)
  return alert_ != NULL ? *alert_ : *default_instance_->alert_;
}
inline ::transit_realtime::Alert* FeedEntity::mutable_alert() {
  set_has_alert();
  if (alert_ == NULL) {
    alert_ = new ::transit_realtime::Alert;
  }
  // @@protoc_insertion_point(field_mutable:transit_realtime.FeedEntity.alert)
  return alert_;
}
inline ::transit_realtime::Alert* FeedEntity::release_alert() {
  // @@protoc_insertion_point(field_release:transit_realtime.FeedEntity.alert)
  clear_has_alert();
  ::transit_realtime::Alert* temp = alert_;
  alert_ = NULL;
  return temp;
}
inline void FeedEntity::set_allocated_alert(::transit_realtime::Alert* alert) {
  delete alert_;
  alert_ = alert;
  if (alert) {
    set_has_alert();
  } else {
    clear_has_alert();
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.FeedEntity.alert)
}

// -------------------------------------------------------------------

// TripUpdate_StopTimeEvent

// optional int32 delay = 1;
inline bool TripUpdate_StopTimeEvent::has_delay() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TripUpdate_StopTimeEvent::set_has_delay() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TripUpdate_StopTimeEvent::clear_has_delay() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TripUpdate_StopTimeEvent::clear_delay() {
  delay_ = 0;
  clear_has_delay();
}
inline ::google::protobuf::int32 TripUpdate_StopTimeEvent::delay() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeEvent.delay)
  return delay_;
}
inline void TripUpdate_StopTimeEvent::set_delay(::google::protobuf::int32 value) {
  set_has_delay();
  delay_ = value;
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.StopTimeEvent.delay)
}

// optional int64 time = 2;
inline bool TripUpdate_StopTimeEvent::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TripUpdate_StopTimeEvent::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TripUpdate_StopTimeEvent::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TripUpdate_StopTimeEvent::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 TripUpdate_StopTimeEvent::time() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeEvent.time)
  return time_;
}
inline void TripUpdate_StopTimeEvent::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.StopTimeEvent.time)
}

// optional int32 uncertainty = 3;
inline bool TripUpdate_StopTimeEvent::has_uncertainty() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TripUpdate_StopTimeEvent::set_has_uncertainty() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TripUpdate_StopTimeEvent::clear_has_uncertainty() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TripUpdate_StopTimeEvent::clear_uncertainty() {
  uncertainty_ = 0;
  clear_has_uncertainty();
}
inline ::google::protobuf::int32 TripUpdate_StopTimeEvent::uncertainty() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeEvent.uncertainty)
  return uncertainty_;
}
inline void TripUpdate_StopTimeEvent::set_uncertainty(::google::protobuf::int32 value) {
  set_has_uncertainty();
  uncertainty_ = value;
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.StopTimeEvent.uncertainty)
}

// -------------------------------------------------------------------

// TripUpdate_StopTimeUpdate

// optional uint32 stop_sequence = 1;
inline bool TripUpdate_StopTimeUpdate::has_stop_sequence() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TripUpdate_StopTimeUpdate::set_has_stop_sequence() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TripUpdate_StopTimeUpdate::clear_has_stop_sequence() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TripUpdate_StopTimeUpdate::clear_stop_sequence() {
  stop_sequence_ = 0u;
  clear_has_stop_sequence();
}
inline ::google::protobuf::uint32 TripUpdate_StopTimeUpdate::stop_sequence() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeUpdate.stop_sequence)
  return stop_sequence_;
}
inline void TripUpdate_StopTimeUpdate::set_stop_sequence(::google::protobuf::uint32 value) {
  set_has_stop_sequence();
  stop_sequence_ = value;
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.StopTimeUpdate.stop_sequence)
}

// optional string stop_id = 4;
inline bool TripUpdate_StopTimeUpdate::has_stop_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TripUpdate_StopTimeUpdate::set_has_stop_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TripUpdate_StopTimeUpdate::clear_has_stop_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TripUpdate_StopTimeUpdate::clear_stop_id() {
  stop_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_stop_id();
}
inline const ::std::string& TripUpdate_StopTimeUpdate::stop_id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeUpdate.stop_id)
  return stop_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TripUpdate_StopTimeUpdate::set_stop_id(const ::std::string& value) {
  set_has_stop_id();
  stop_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.StopTimeUpdate.stop_id)
}
inline void TripUpdate_StopTimeUpdate::set_stop_id(const char* value) {
  set_has_stop_id();
  stop_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transit_realtime.TripUpdate.StopTimeUpdate.stop_id)
}
inline void TripUpdate_StopTimeUpdate::set_stop_id(const char* value, size_t size) {
  set_has_stop_id();
  stop_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transit_realtime.TripUpdate.StopTimeUpdate.stop_id)
}
inline ::std::string* TripUpdate_StopTimeUpdate::mutable_stop_id() {
  set_has_stop_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.StopTimeUpdate.stop_id)
  return stop_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TripUpdate_StopTimeUpdate::release_stop_id() {
  // @@protoc_insertion_point(field_release:transit_realtime.TripUpdate.StopTimeUpdate.stop_id)
  clear_has_stop_id();
  return stop_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TripUpdate_StopTimeUpdate::set_allocated_stop_id(::std::string* stop_id) {
  if (stop_id != NULL) {
    set_has_stop_id();
  } else {
    clear_has_stop_id();
  }
  stop_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), stop_id);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripUpdate.StopTimeUpdate.stop_id)
}

// optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;
inline bool TripUpdate_StopTimeUpdate::has_arrival() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TripUpdate_StopTimeUpdate::set_has_arrival() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TripUpdate_StopTimeUpdate::clear_has_arrival() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TripUpdate_StopTimeUpdate::clear_arrival() {
  if (arrival_ != NULL) arrival_->::transit_realtime::TripUpdate_StopTimeEvent::Clear();
  clear_has_arrival();
}
inline const ::transit_realtime::TripUpdate_StopTimeEvent& TripUpdate_StopTimeUpdate::arrival() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeUpdate.arrival)
  return arrival_ != NULL ? *arrival_ : *default_instance_->arrival_;
}
inline ::transit_realtime::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::mutable_arrival() {
  set_has_arrival();
  if (arrival_ == NULL) {
    arrival_ = new ::transit_realtime::TripUpdate_StopTimeEvent;
  }
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.StopTimeUpdate.arrival)
  return arrival_;
}
inline ::transit_realtime::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::release_arrival() {
  // @@protoc_insertion_point(field_release:transit_realtime.TripUpdate.StopTimeUpdate.arrival)
  clear_has_arrival();
  ::transit_realtime::TripUpdate_StopTimeEvent* temp = arrival_;
  arrival_ = NULL;
  return temp;
}
inline void TripUpdate_StopTimeUpdate::set_allocated_arrival(::transit_realtime::TripUpdate_StopTimeEvent* arrival) {
  delete arrival_;
  arrival_ = arrival;
  if (arrival) {
    set_has_arrival();
  } else {
    clear_has_arrival();
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripUpdate.StopTimeUpdate.arrival)
}

// optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;
inline bool TripUpdate_StopTimeUpdate::has_departure() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TripUpdate_StopTimeUpdate::set_has_departure() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TripUpdate_StopTimeUpdate::clear_has_departure() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TripUpdate_StopTimeUpdate::clear_departure() {
  if (departure_ != NULL) departure_->::transit_realtime::TripUpdate_StopTimeEvent::Clear();
  clear_has_departure();
}
inline const ::transit_realtime::TripUpdate_StopTimeEvent& TripUpdate_StopTimeUpdate::departure() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeUpdate.departure)
  return departure_ != NULL ? *departure_ : *default_instance_->departure_;
}
inline ::transit_realtime::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::mutable_departure() {
  set_has_departure();
  if (departure_ == NULL) {
    departure_ = new ::transit_realtime::TripUpdate_StopTimeEvent;
  }
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.StopTimeUpdate.departure)
  return departure_;
}
inline ::transit_realtime::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::release_departure() {
  // @@protoc_insertion_point(field_release:transit_realtime.TripUpdate.StopTimeUpdate.departure)
  clear_has_departure();
  ::transit_realtime::TripUpdate_StopTimeEvent* temp = departure_;
  departure_ = NULL;
  return temp;
}
inline void TripUpdate_StopTimeUpdate::set_allocated_departure(::transit_realtime::TripUpdate_StopTimeEvent* departure) {
  delete departure_;
  departure_ = departure;
  if (departure) {
    set_has_departure();
  } else {
    clear_has_departure();
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripUpdate.StopTimeUpdate.departure)
}

// optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED];
inline bool TripUpdate_StopTimeUpdate::has_schedule_relationship() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TripUpdate_StopTimeUpdate::set_has_schedule_relationship() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TripUpdate_StopTimeUpdate::clear_has_schedule_relationship() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TripUpdate_StopTimeUpdate::clear_schedule_relationship() {
  schedule_relationship_ = 0;
  clear_has_schedule_relationship();
}
inline ::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship TripUpdate_StopTimeUpdate::schedule_relationship() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.StopTimeUpdate.schedule_relationship)
  return static_cast< ::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship >(schedule_relationship_);
}
inline void TripUpdate_StopTimeUpdate::set_schedule_relationship(::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship value) {
  assert(::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship_IsValid(value));
  set_has_schedule_relationship();
  schedule_relationship_ = value;
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.StopTimeUpdate.schedule_relationship)
}

// -------------------------------------------------------------------

// TripUpdate

// required .transit_realtime.TripDescriptor trip = 1;
inline bool TripUpdate::has_trip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TripUpdate::set_has_trip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TripUpdate::clear_has_trip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TripUpdate::clear_trip() {
  if (trip_ != NULL) trip_->::transit_realtime::TripDescriptor::Clear();
  clear_has_trip();
}
inline const ::transit_realtime::TripDescriptor& TripUpdate::trip() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.trip)
  return trip_ != NULL ? *trip_ : *default_instance_->trip_;
}
inline ::transit_realtime::TripDescriptor* TripUpdate::mutable_trip() {
  set_has_trip();
  if (trip_ == NULL) {
    trip_ = new ::transit_realtime::TripDescriptor;
  }
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.trip)
  return trip_;
}
inline ::transit_realtime::TripDescriptor* TripUpdate::release_trip() {
  // @@protoc_insertion_point(field_release:transit_realtime.TripUpdate.trip)
  clear_has_trip();
  ::transit_realtime::TripDescriptor* temp = trip_;
  trip_ = NULL;
  return temp;
}
inline void TripUpdate::set_allocated_trip(::transit_realtime::TripDescriptor* trip) {
  delete trip_;
  trip_ = trip;
  if (trip) {
    set_has_trip();
  } else {
    clear_has_trip();
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripUpdate.trip)
}

// optional .transit_realtime.VehicleDescriptor vehicle = 3;
inline bool TripUpdate::has_vehicle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TripUpdate::set_has_vehicle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TripUpdate::clear_has_vehicle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TripUpdate::clear_vehicle() {
  if (vehicle_ != NULL) vehicle_->::transit_realtime::VehicleDescriptor::Clear();
  clear_has_vehicle();
}
inline const ::transit_realtime::VehicleDescriptor& TripUpdate::vehicle() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.vehicle)
  return vehicle_ != NULL ? *vehicle_ : *default_instance_->vehicle_;
}
inline ::transit_realtime::VehicleDescriptor* TripUpdate::mutable_vehicle() {
  set_has_vehicle();
  if (vehicle_ == NULL) {
    vehicle_ = new ::transit_realtime::VehicleDescriptor;
  }
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.vehicle)
  return vehicle_;
}
inline ::transit_realtime::VehicleDescriptor* TripUpdate::release_vehicle() {
  // @@protoc_insertion_point(field_release:transit_realtime.TripUpdate.vehicle)
  clear_has_vehicle();
  ::transit_realtime::VehicleDescriptor* temp = vehicle_;
  vehicle_ = NULL;
  return temp;
}
inline void TripUpdate::set_allocated_vehicle(::transit_realtime::VehicleDescriptor* vehicle) {
  delete vehicle_;
  vehicle_ = vehicle;
  if (vehicle) {
    set_has_vehicle();
  } else {
    clear_has_vehicle();
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripUpdate.vehicle)
}

// repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;
inline int TripUpdate::stop_time_update_size() const {
  return stop_time_update_.size();
}
inline void TripUpdate::clear_stop_time_update() {
  stop_time_update_.Clear();
}
inline const ::transit_realtime::TripUpdate_StopTimeUpdate& TripUpdate::stop_time_update(int index) const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.stop_time_update)
  return stop_time_update_.Get(index);
}
inline ::transit_realtime::TripUpdate_StopTimeUpdate* TripUpdate::mutable_stop_time_update(int index) {
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripUpdate.stop_time_update)
  return stop_time_update_.Mutable(index);
}
inline ::transit_realtime::TripUpdate_StopTimeUpdate* TripUpdate::add_stop_time_update() {
  // @@protoc_insertion_point(field_add:transit_realtime.TripUpdate.stop_time_update)
  return stop_time_update_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::transit_realtime::TripUpdate_StopTimeUpdate >*
TripUpdate::mutable_stop_time_update() {
  // @@protoc_insertion_point(field_mutable_list:transit_realtime.TripUpdate.stop_time_update)
  return &stop_time_update_;
}
inline const ::google::protobuf::RepeatedPtrField< ::transit_realtime::TripUpdate_StopTimeUpdate >&
TripUpdate::stop_time_update() const {
  // @@protoc_insertion_point(field_list:transit_realtime.TripUpdate.stop_time_update)
  return stop_time_update_;
}

// optional uint64 timestamp = 4;
inline bool TripUpdate::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TripUpdate::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TripUpdate::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TripUpdate::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 TripUpdate::timestamp() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripUpdate.timestamp)
  return timestamp_;
}
inline void TripUpdate::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:transit_realtime.TripUpdate.timestamp)
}

// -------------------------------------------------------------------

// VehiclePosition

// optional .transit_realtime.TripDescriptor trip = 1;
inline bool VehiclePosition::has_trip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VehiclePosition::set_has_trip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VehiclePosition::clear_has_trip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VehiclePosition::clear_trip() {
  if (trip_ != NULL) trip_->::transit_realtime::TripDescriptor::Clear();
  clear_has_trip();
}
inline const ::transit_realtime::TripDescriptor& VehiclePosition::trip() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.trip)
  return trip_ != NULL ? *trip_ : *default_instance_->trip_;
}
inline ::transit_realtime::TripDescriptor* VehiclePosition::mutable_trip() {
  set_has_trip();
  if (trip_ == NULL) {
    trip_ = new ::transit_realtime::TripDescriptor;
  }
  // @@protoc_insertion_point(field_mutable:transit_realtime.VehiclePosition.trip)
  return trip_;
}
inline ::transit_realtime::TripDescriptor* VehiclePosition::release_trip() {
  // @@protoc_insertion_point(field_release:transit_realtime.VehiclePosition.trip)
  clear_has_trip();
  ::transit_realtime::TripDescriptor* temp = trip_;
  trip_ = NULL;
  return temp;
}
inline void VehiclePosition::set_allocated_trip(::transit_realtime::TripDescriptor* trip) {
  delete trip_;
  trip_ = trip;
  if (trip) {
    set_has_trip();
  } else {
    clear_has_trip();
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.VehiclePosition.trip)
}

// optional .transit_realtime.VehicleDescriptor vehicle = 8;
inline bool VehiclePosition::has_vehicle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VehiclePosition::set_has_vehicle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VehiclePosition::clear_has_vehicle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VehiclePosition::clear_vehicle() {
  if (vehicle_ != NULL) vehicle_->::transit_realtime::VehicleDescriptor::Clear();
  clear_has_vehicle();
}
inline const ::transit_realtime::VehicleDescriptor& VehiclePosition::vehicle() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.vehicle)
  return vehicle_ != NULL ? *vehicle_ : *default_instance_->vehicle_;
}
inline ::transit_realtime::VehicleDescriptor* VehiclePosition::mutable_vehicle() {
  set_has_vehicle();
  if (vehicle_ == NULL) {
    vehicle_ = new ::transit_realtime::VehicleDescriptor;
  }
  // @@protoc_insertion_point(field_mutable:transit_realtime.VehiclePosition.vehicle)
  return vehicle_;
}
inline ::transit_realtime::VehicleDescriptor* VehiclePosition::release_vehicle() {
  // @@protoc_insertion_point(field_release:transit_realtime.VehiclePosition.vehicle)
  clear_has_vehicle();
  ::transit_realtime::VehicleDescriptor* temp = vehicle_;
  vehicle_ = NULL;
  return temp;
}
inline void VehiclePosition::set_allocated_vehicle(::transit_realtime::VehicleDescriptor* vehicle) {
  delete vehicle_;
  vehicle_ = vehicle;
  if (vehicle) {
    set_has_vehicle();
  } else {
    clear_has_vehicle();
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.VehiclePosition.vehicle)
}

// optional .transit_realtime.Position position = 2;
inline bool VehiclePosition::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VehiclePosition::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VehiclePosition::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VehiclePosition::clear_position() {
  if (position_ != NULL) position_->::transit_realtime::Position::Clear();
  clear_has_position();
}
inline const ::transit_realtime::Position& VehiclePosition::position() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::transit_realtime::Position* VehiclePosition::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::transit_realtime::Position;
  }
  // @@protoc_insertion_point(field_mutable:transit_realtime.VehiclePosition.position)
  return position_;
}
inline ::transit_realtime::Position* VehiclePosition::release_position() {
  // @@protoc_insertion_point(field_release:transit_realtime.VehiclePosition.position)
  clear_has_position();
  ::transit_realtime::Position* temp = position_;
  position_ = NULL;
  return temp;
}
inline void VehiclePosition::set_allocated_position(::transit_realtime::Position* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.VehiclePosition.position)
}

// optional uint32 current_stop_sequence = 3;
inline bool VehiclePosition::has_current_stop_sequence() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VehiclePosition::set_has_current_stop_sequence() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VehiclePosition::clear_has_current_stop_sequence() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VehiclePosition::clear_current_stop_sequence() {
  current_stop_sequence_ = 0u;
  clear_has_current_stop_sequence();
}
inline ::google::protobuf::uint32 VehiclePosition::current_stop_sequence() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.current_stop_sequence)
  return current_stop_sequence_;
}
inline void VehiclePosition::set_current_stop_sequence(::google::protobuf::uint32 value) {
  set_has_current_stop_sequence();
  current_stop_sequence_ = value;
  // @@protoc_insertion_point(field_set:transit_realtime.VehiclePosition.current_stop_sequence)
}

// optional string stop_id = 7;
inline bool VehiclePosition::has_stop_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VehiclePosition::set_has_stop_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VehiclePosition::clear_has_stop_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VehiclePosition::clear_stop_id() {
  stop_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_stop_id();
}
inline const ::std::string& VehiclePosition::stop_id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.stop_id)
  return stop_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VehiclePosition::set_stop_id(const ::std::string& value) {
  set_has_stop_id();
  stop_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transit_realtime.VehiclePosition.stop_id)
}
inline void VehiclePosition::set_stop_id(const char* value) {
  set_has_stop_id();
  stop_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transit_realtime.VehiclePosition.stop_id)
}
inline void VehiclePosition::set_stop_id(const char* value, size_t size) {
  set_has_stop_id();
  stop_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transit_realtime.VehiclePosition.stop_id)
}
inline ::std::string* VehiclePosition::mutable_stop_id() {
  set_has_stop_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.VehiclePosition.stop_id)
  return stop_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VehiclePosition::release_stop_id() {
  // @@protoc_insertion_point(field_release:transit_realtime.VehiclePosition.stop_id)
  clear_has_stop_id();
  return stop_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VehiclePosition::set_allocated_stop_id(::std::string* stop_id) {
  if (stop_id != NULL) {
    set_has_stop_id();
  } else {
    clear_has_stop_id();
  }
  stop_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), stop_id);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.VehiclePosition.stop_id)
}

// optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];
inline bool VehiclePosition::has_current_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VehiclePosition::set_has_current_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VehiclePosition::clear_has_current_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VehiclePosition::clear_current_status() {
  current_status_ = 2;
  clear_has_current_status();
}
inline ::transit_realtime::VehiclePosition_VehicleStopStatus VehiclePosition::current_status() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.current_status)
  return static_cast< ::transit_realtime::VehiclePosition_VehicleStopStatus >(current_status_);
}
inline void VehiclePosition::set_current_status(::transit_realtime::VehiclePosition_VehicleStopStatus value) {
  assert(::transit_realtime::VehiclePosition_VehicleStopStatus_IsValid(value));
  set_has_current_status();
  current_status_ = value;
  // @@protoc_insertion_point(field_set:transit_realtime.VehiclePosition.current_status)
}

// optional uint64 timestamp = 5;
inline bool VehiclePosition::has_timestamp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VehiclePosition::set_has_timestamp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VehiclePosition::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VehiclePosition::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 VehiclePosition::timestamp() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.timestamp)
  return timestamp_;
}
inline void VehiclePosition::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:transit_realtime.VehiclePosition.timestamp)
}

// optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;
inline bool VehiclePosition::has_congestion_level() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VehiclePosition::set_has_congestion_level() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VehiclePosition::clear_has_congestion_level() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VehiclePosition::clear_congestion_level() {
  congestion_level_ = 0;
  clear_has_congestion_level();
}
inline ::transit_realtime::VehiclePosition_CongestionLevel VehiclePosition::congestion_level() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.congestion_level)
  return static_cast< ::transit_realtime::VehiclePosition_CongestionLevel >(congestion_level_);
}
inline void VehiclePosition::set_congestion_level(::transit_realtime::VehiclePosition_CongestionLevel value) {
  assert(::transit_realtime::VehiclePosition_CongestionLevel_IsValid(value));
  set_has_congestion_level();
  congestion_level_ = value;
  // @@protoc_insertion_point(field_set:transit_realtime.VehiclePosition.congestion_level)
}

// optional .transit_realtime.OVapiVehiclePosition ovapi_vehicle_position = 1003;
inline bool VehiclePosition::has_ovapi_vehicle_position() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void VehiclePosition::set_has_ovapi_vehicle_position() {
  _has_bits_[0] |= 0x00000100u;
}
inline void VehiclePosition::clear_has_ovapi_vehicle_position() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void VehiclePosition::clear_ovapi_vehicle_position() {
  if (ovapi_vehicle_position_ != NULL) ovapi_vehicle_position_->::transit_realtime::OVapiVehiclePosition::Clear();
  clear_has_ovapi_vehicle_position();
}
inline const ::transit_realtime::OVapiVehiclePosition& VehiclePosition::ovapi_vehicle_position() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehiclePosition.ovapi_vehicle_position)
  return ovapi_vehicle_position_ != NULL ? *ovapi_vehicle_position_ : *default_instance_->ovapi_vehicle_position_;
}
inline ::transit_realtime::OVapiVehiclePosition* VehiclePosition::mutable_ovapi_vehicle_position() {
  set_has_ovapi_vehicle_position();
  if (ovapi_vehicle_position_ == NULL) {
    ovapi_vehicle_position_ = new ::transit_realtime::OVapiVehiclePosition;
  }
  // @@protoc_insertion_point(field_mutable:transit_realtime.VehiclePosition.ovapi_vehicle_position)
  return ovapi_vehicle_position_;
}
inline ::transit_realtime::OVapiVehiclePosition* VehiclePosition::release_ovapi_vehicle_position() {
  // @@protoc_insertion_point(field_release:transit_realtime.VehiclePosition.ovapi_vehicle_position)
  clear_has_ovapi_vehicle_position();
  ::transit_realtime::OVapiVehiclePosition* temp = ovapi_vehicle_position_;
  ovapi_vehicle_position_ = NULL;
  return temp;
}
inline void VehiclePosition::set_allocated_ovapi_vehicle_position(::transit_realtime::OVapiVehiclePosition* ovapi_vehicle_position) {
  delete ovapi_vehicle_position_;
  ovapi_vehicle_position_ = ovapi_vehicle_position;
  if (ovapi_vehicle_position) {
    set_has_ovapi_vehicle_position();
  } else {
    clear_has_ovapi_vehicle_position();
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.VehiclePosition.ovapi_vehicle_position)
}

// -------------------------------------------------------------------

// OVapiVehiclePosition

// optional int32 delay = 1;
inline bool OVapiVehiclePosition::has_delay() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OVapiVehiclePosition::set_has_delay() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OVapiVehiclePosition::clear_has_delay() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OVapiVehiclePosition::clear_delay() {
  delay_ = 0;
  clear_has_delay();
}
inline ::google::protobuf::int32 OVapiVehiclePosition::delay() const {
  // @@protoc_insertion_point(field_get:transit_realtime.OVapiVehiclePosition.delay)
  return delay_;
}
inline void OVapiVehiclePosition::set_delay(::google::protobuf::int32 value) {
  set_has_delay();
  delay_ = value;
  // @@protoc_insertion_point(field_set:transit_realtime.OVapiVehiclePosition.delay)
}

// -------------------------------------------------------------------

// Alert

// repeated .transit_realtime.TimeRange active_period = 1;
inline int Alert::active_period_size() const {
  return active_period_.size();
}
inline void Alert::clear_active_period() {
  active_period_.Clear();
}
inline const ::transit_realtime::TimeRange& Alert::active_period(int index) const {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.active_period)
  return active_period_.Get(index);
}
inline ::transit_realtime::TimeRange* Alert::mutable_active_period(int index) {
  // @@protoc_insertion_point(field_mutable:transit_realtime.Alert.active_period)
  return active_period_.Mutable(index);
}
inline ::transit_realtime::TimeRange* Alert::add_active_period() {
  // @@protoc_insertion_point(field_add:transit_realtime.Alert.active_period)
  return active_period_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::transit_realtime::TimeRange >*
Alert::mutable_active_period() {
  // @@protoc_insertion_point(field_mutable_list:transit_realtime.Alert.active_period)
  return &active_period_;
}
inline const ::google::protobuf::RepeatedPtrField< ::transit_realtime::TimeRange >&
Alert::active_period() const {
  // @@protoc_insertion_point(field_list:transit_realtime.Alert.active_period)
  return active_period_;
}

// repeated .transit_realtime.EntitySelector informed_entity = 5;
inline int Alert::informed_entity_size() const {
  return informed_entity_.size();
}
inline void Alert::clear_informed_entity() {
  informed_entity_.Clear();
}
inline const ::transit_realtime::EntitySelector& Alert::informed_entity(int index) const {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.informed_entity)
  return informed_entity_.Get(index);
}
inline ::transit_realtime::EntitySelector* Alert::mutable_informed_entity(int index) {
  // @@protoc_insertion_point(field_mutable:transit_realtime.Alert.informed_entity)
  return informed_entity_.Mutable(index);
}
inline ::transit_realtime::EntitySelector* Alert::add_informed_entity() {
  // @@protoc_insertion_point(field_add:transit_realtime.Alert.informed_entity)
  return informed_entity_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::transit_realtime::EntitySelector >*
Alert::mutable_informed_entity() {
  // @@protoc_insertion_point(field_mutable_list:transit_realtime.Alert.informed_entity)
  return &informed_entity_;
}
inline const ::google::protobuf::RepeatedPtrField< ::transit_realtime::EntitySelector >&
Alert::informed_entity() const {
  // @@protoc_insertion_point(field_list:transit_realtime.Alert.informed_entity)
  return informed_entity_;
}

// optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE];
inline bool Alert::has_cause() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Alert::set_has_cause() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Alert::clear_has_cause() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Alert::clear_cause() {
  cause_ = 1;
  clear_has_cause();
}
inline ::transit_realtime::Alert_Cause Alert::cause() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.cause)
  return static_cast< ::transit_realtime::Alert_Cause >(cause_);
}
inline void Alert::set_cause(::transit_realtime::Alert_Cause value) {
  assert(::transit_realtime::Alert_Cause_IsValid(value));
  set_has_cause();
  cause_ = value;
  // @@protoc_insertion_point(field_set:transit_realtime.Alert.cause)
}

// optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT];
inline bool Alert::has_effect() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Alert::set_has_effect() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Alert::clear_has_effect() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Alert::clear_effect() {
  effect_ = 8;
  clear_has_effect();
}
inline ::transit_realtime::Alert_Effect Alert::effect() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.effect)
  return static_cast< ::transit_realtime::Alert_Effect >(effect_);
}
inline void Alert::set_effect(::transit_realtime::Alert_Effect value) {
  assert(::transit_realtime::Alert_Effect_IsValid(value));
  set_has_effect();
  effect_ = value;
  // @@protoc_insertion_point(field_set:transit_realtime.Alert.effect)
}

// optional .transit_realtime.TranslatedString url = 8;
inline bool Alert::has_url() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Alert::set_has_url() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Alert::clear_has_url() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Alert::clear_url() {
  if (url_ != NULL) url_->::transit_realtime::TranslatedString::Clear();
  clear_has_url();
}
inline const ::transit_realtime::TranslatedString& Alert::url() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.url)
  return url_ != NULL ? *url_ : *default_instance_->url_;
}
inline ::transit_realtime::TranslatedString* Alert::mutable_url() {
  set_has_url();
  if (url_ == NULL) {
    url_ = new ::transit_realtime::TranslatedString;
  }
  // @@protoc_insertion_point(field_mutable:transit_realtime.Alert.url)
  return url_;
}
inline ::transit_realtime::TranslatedString* Alert::release_url() {
  // @@protoc_insertion_point(field_release:transit_realtime.Alert.url)
  clear_has_url();
  ::transit_realtime::TranslatedString* temp = url_;
  url_ = NULL;
  return temp;
}
inline void Alert::set_allocated_url(::transit_realtime::TranslatedString* url) {
  delete url_;
  url_ = url;
  if (url) {
    set_has_url();
  } else {
    clear_has_url();
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Alert.url)
}

// optional .transit_realtime.TranslatedString header_text = 10;
inline bool Alert::has_header_text() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Alert::set_has_header_text() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Alert::clear_has_header_text() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Alert::clear_header_text() {
  if (header_text_ != NULL) header_text_->::transit_realtime::TranslatedString::Clear();
  clear_has_header_text();
}
inline const ::transit_realtime::TranslatedString& Alert::header_text() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.header_text)
  return header_text_ != NULL ? *header_text_ : *default_instance_->header_text_;
}
inline ::transit_realtime::TranslatedString* Alert::mutable_header_text() {
  set_has_header_text();
  if (header_text_ == NULL) {
    header_text_ = new ::transit_realtime::TranslatedString;
  }
  // @@protoc_insertion_point(field_mutable:transit_realtime.Alert.header_text)
  return header_text_;
}
inline ::transit_realtime::TranslatedString* Alert::release_header_text() {
  // @@protoc_insertion_point(field_release:transit_realtime.Alert.header_text)
  clear_has_header_text();
  ::transit_realtime::TranslatedString* temp = header_text_;
  header_text_ = NULL;
  return temp;
}
inline void Alert::set_allocated_header_text(::transit_realtime::TranslatedString* header_text) {
  delete header_text_;
  header_text_ = header_text;
  if (header_text) {
    set_has_header_text();
  } else {
    clear_has_header_text();
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Alert.header_text)
}

// optional .transit_realtime.TranslatedString description_text = 11;
inline bool Alert::has_description_text() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Alert::set_has_description_text() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Alert::clear_has_description_text() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Alert::clear_description_text() {
  if (description_text_ != NULL) description_text_->::transit_realtime::TranslatedString::Clear();
  clear_has_description_text();
}
inline const ::transit_realtime::TranslatedString& Alert::description_text() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Alert.description_text)
  return description_text_ != NULL ? *description_text_ : *default_instance_->description_text_;
}
inline ::transit_realtime::TranslatedString* Alert::mutable_description_text() {
  set_has_description_text();
  if (description_text_ == NULL) {
    description_text_ = new ::transit_realtime::TranslatedString;
  }
  // @@protoc_insertion_point(field_mutable:transit_realtime.Alert.description_text)
  return description_text_;
}
inline ::transit_realtime::TranslatedString* Alert::release_description_text() {
  // @@protoc_insertion_point(field_release:transit_realtime.Alert.description_text)
  clear_has_description_text();
  ::transit_realtime::TranslatedString* temp = description_text_;
  description_text_ = NULL;
  return temp;
}
inline void Alert::set_allocated_description_text(::transit_realtime::TranslatedString* description_text) {
  delete description_text_;
  description_text_ = description_text;
  if (description_text) {
    set_has_description_text();
  } else {
    clear_has_description_text();
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.Alert.description_text)
}

// -------------------------------------------------------------------

// TimeRange

// optional uint64 start = 1;
inline bool TimeRange::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimeRange::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimeRange::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimeRange::clear_start() {
  start_ = GOOGLE_ULONGLONG(0);
  clear_has_start();
}
inline ::google::protobuf::uint64 TimeRange::start() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TimeRange.start)
  return start_;
}
inline void TimeRange::set_start(::google::protobuf::uint64 value) {
  set_has_start();
  start_ = value;
  // @@protoc_insertion_point(field_set:transit_realtime.TimeRange.start)
}

// optional uint64 end = 2;
inline bool TimeRange::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimeRange::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimeRange::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimeRange::clear_end() {
  end_ = GOOGLE_ULONGLONG(0);
  clear_has_end();
}
inline ::google::protobuf::uint64 TimeRange::end() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TimeRange.end)
  return end_;
}
inline void TimeRange::set_end(::google::protobuf::uint64 value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:transit_realtime.TimeRange.end)
}

// -------------------------------------------------------------------

// Position

// required float latitude = 1;
inline bool Position::has_latitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Position::set_has_latitude() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Position::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Position::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline float Position::latitude() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Position.latitude)
  return latitude_;
}
inline void Position::set_latitude(float value) {
  set_has_latitude();
  latitude_ = value;
  // @@protoc_insertion_point(field_set:transit_realtime.Position.latitude)
}

// required float longitude = 2;
inline bool Position::has_longitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Position::set_has_longitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Position::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Position::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline float Position::longitude() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Position.longitude)
  return longitude_;
}
inline void Position::set_longitude(float value) {
  set_has_longitude();
  longitude_ = value;
  // @@protoc_insertion_point(field_set:transit_realtime.Position.longitude)
}

// optional float bearing = 3;
inline bool Position::has_bearing() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Position::set_has_bearing() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Position::clear_has_bearing() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Position::clear_bearing() {
  bearing_ = 0;
  clear_has_bearing();
}
inline float Position::bearing() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Position.bearing)
  return bearing_;
}
inline void Position::set_bearing(float value) {
  set_has_bearing();
  bearing_ = value;
  // @@protoc_insertion_point(field_set:transit_realtime.Position.bearing)
}

// optional double odometer = 4;
inline bool Position::has_odometer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Position::set_has_odometer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Position::clear_has_odometer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Position::clear_odometer() {
  odometer_ = 0;
  clear_has_odometer();
}
inline double Position::odometer() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Position.odometer)
  return odometer_;
}
inline void Position::set_odometer(double value) {
  set_has_odometer();
  odometer_ = value;
  // @@protoc_insertion_point(field_set:transit_realtime.Position.odometer)
}

// optional float speed = 5;
inline bool Position::has_speed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Position::set_has_speed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Position::clear_has_speed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Position::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline float Position::speed() const {
  // @@protoc_insertion_point(field_get:transit_realtime.Position.speed)
  return speed_;
}
inline void Position::set_speed(float value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:transit_realtime.Position.speed)
}

// -------------------------------------------------------------------

// TripDescriptor

// optional string trip_id = 1;
inline bool TripDescriptor::has_trip_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TripDescriptor::set_has_trip_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TripDescriptor::clear_has_trip_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TripDescriptor::clear_trip_id() {
  trip_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_trip_id();
}
inline const ::std::string& TripDescriptor::trip_id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripDescriptor.trip_id)
  return trip_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TripDescriptor::set_trip_id(const ::std::string& value) {
  set_has_trip_id();
  trip_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transit_realtime.TripDescriptor.trip_id)
}
inline void TripDescriptor::set_trip_id(const char* value) {
  set_has_trip_id();
  trip_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transit_realtime.TripDescriptor.trip_id)
}
inline void TripDescriptor::set_trip_id(const char* value, size_t size) {
  set_has_trip_id();
  trip_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transit_realtime.TripDescriptor.trip_id)
}
inline ::std::string* TripDescriptor::mutable_trip_id() {
  set_has_trip_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripDescriptor.trip_id)
  return trip_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TripDescriptor::release_trip_id() {
  // @@protoc_insertion_point(field_release:transit_realtime.TripDescriptor.trip_id)
  clear_has_trip_id();
  return trip_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TripDescriptor::set_allocated_trip_id(::std::string* trip_id) {
  if (trip_id != NULL) {
    set_has_trip_id();
  } else {
    clear_has_trip_id();
  }
  trip_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), trip_id);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripDescriptor.trip_id)
}

// optional string route_id = 5;
inline bool TripDescriptor::has_route_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TripDescriptor::set_has_route_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TripDescriptor::clear_has_route_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TripDescriptor::clear_route_id() {
  route_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_route_id();
}
inline const ::std::string& TripDescriptor::route_id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripDescriptor.route_id)
  return route_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TripDescriptor::set_route_id(const ::std::string& value) {
  set_has_route_id();
  route_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transit_realtime.TripDescriptor.route_id)
}
inline void TripDescriptor::set_route_id(const char* value) {
  set_has_route_id();
  route_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transit_realtime.TripDescriptor.route_id)
}
inline void TripDescriptor::set_route_id(const char* value, size_t size) {
  set_has_route_id();
  route_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transit_realtime.TripDescriptor.route_id)
}
inline ::std::string* TripDescriptor::mutable_route_id() {
  set_has_route_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripDescriptor.route_id)
  return route_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TripDescriptor::release_route_id() {
  // @@protoc_insertion_point(field_release:transit_realtime.TripDescriptor.route_id)
  clear_has_route_id();
  return route_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TripDescriptor::set_allocated_route_id(::std::string* route_id) {
  if (route_id != NULL) {
    set_has_route_id();
  } else {
    clear_has_route_id();
  }
  route_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), route_id);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripDescriptor.route_id)
}

// optional string start_time = 2;
inline bool TripDescriptor::has_start_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TripDescriptor::set_has_start_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TripDescriptor::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TripDescriptor::clear_start_time() {
  start_time_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_start_time();
}
inline const ::std::string& TripDescriptor::start_time() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripDescriptor.start_time)
  return start_time_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TripDescriptor::set_start_time(const ::std::string& value) {
  set_has_start_time();
  start_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transit_realtime.TripDescriptor.start_time)
}
inline void TripDescriptor::set_start_time(const char* value) {
  set_has_start_time();
  start_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transit_realtime.TripDescriptor.start_time)
}
inline void TripDescriptor::set_start_time(const char* value, size_t size) {
  set_has_start_time();
  start_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transit_realtime.TripDescriptor.start_time)
}
inline ::std::string* TripDescriptor::mutable_start_time() {
  set_has_start_time();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripDescriptor.start_time)
  return start_time_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TripDescriptor::release_start_time() {
  // @@protoc_insertion_point(field_release:transit_realtime.TripDescriptor.start_time)
  clear_has_start_time();
  return start_time_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TripDescriptor::set_allocated_start_time(::std::string* start_time) {
  if (start_time != NULL) {
    set_has_start_time();
  } else {
    clear_has_start_time();
  }
  start_time_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start_time);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripDescriptor.start_time)
}

// optional string start_date = 3;
inline bool TripDescriptor::has_start_date() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TripDescriptor::set_has_start_date() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TripDescriptor::clear_has_start_date() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TripDescriptor::clear_start_date() {
  start_date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_start_date();
}
inline const ::std::string& TripDescriptor::start_date() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripDescriptor.start_date)
  return start_date_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TripDescriptor::set_start_date(const ::std::string& value) {
  set_has_start_date();
  start_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transit_realtime.TripDescriptor.start_date)
}
inline void TripDescriptor::set_start_date(const char* value) {
  set_has_start_date();
  start_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transit_realtime.TripDescriptor.start_date)
}
inline void TripDescriptor::set_start_date(const char* value, size_t size) {
  set_has_start_date();
  start_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transit_realtime.TripDescriptor.start_date)
}
inline ::std::string* TripDescriptor::mutable_start_date() {
  set_has_start_date();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TripDescriptor.start_date)
  return start_date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TripDescriptor::release_start_date() {
  // @@protoc_insertion_point(field_release:transit_realtime.TripDescriptor.start_date)
  clear_has_start_date();
  return start_date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TripDescriptor::set_allocated_start_date(::std::string* start_date) {
  if (start_date != NULL) {
    set_has_start_date();
  } else {
    clear_has_start_date();
  }
  start_date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start_date);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TripDescriptor.start_date)
}

// optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;
inline bool TripDescriptor::has_schedule_relationship() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TripDescriptor::set_has_schedule_relationship() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TripDescriptor::clear_has_schedule_relationship() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TripDescriptor::clear_schedule_relationship() {
  schedule_relationship_ = 0;
  clear_has_schedule_relationship();
}
inline ::transit_realtime::TripDescriptor_ScheduleRelationship TripDescriptor::schedule_relationship() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TripDescriptor.schedule_relationship)
  return static_cast< ::transit_realtime::TripDescriptor_ScheduleRelationship >(schedule_relationship_);
}
inline void TripDescriptor::set_schedule_relationship(::transit_realtime::TripDescriptor_ScheduleRelationship value) {
  assert(::transit_realtime::TripDescriptor_ScheduleRelationship_IsValid(value));
  set_has_schedule_relationship();
  schedule_relationship_ = value;
  // @@protoc_insertion_point(field_set:transit_realtime.TripDescriptor.schedule_relationship)
}

// -------------------------------------------------------------------

// VehicleDescriptor

// optional string id = 1;
inline bool VehicleDescriptor::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VehicleDescriptor::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VehicleDescriptor::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VehicleDescriptor::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& VehicleDescriptor::id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehicleDescriptor.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VehicleDescriptor::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transit_realtime.VehicleDescriptor.id)
}
inline void VehicleDescriptor::set_id(const char* value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transit_realtime.VehicleDescriptor.id)
}
inline void VehicleDescriptor::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transit_realtime.VehicleDescriptor.id)
}
inline ::std::string* VehicleDescriptor::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.VehicleDescriptor.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VehicleDescriptor::release_id() {
  // @@protoc_insertion_point(field_release:transit_realtime.VehicleDescriptor.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VehicleDescriptor::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.VehicleDescriptor.id)
}

// optional string label = 2;
inline bool VehicleDescriptor::has_label() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VehicleDescriptor::set_has_label() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VehicleDescriptor::clear_has_label() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VehicleDescriptor::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_label();
}
inline const ::std::string& VehicleDescriptor::label() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehicleDescriptor.label)
  return label_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VehicleDescriptor::set_label(const ::std::string& value) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transit_realtime.VehicleDescriptor.label)
}
inline void VehicleDescriptor::set_label(const char* value) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transit_realtime.VehicleDescriptor.label)
}
inline void VehicleDescriptor::set_label(const char* value, size_t size) {
  set_has_label();
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transit_realtime.VehicleDescriptor.label)
}
inline ::std::string* VehicleDescriptor::mutable_label() {
  set_has_label();
  // @@protoc_insertion_point(field_mutable:transit_realtime.VehicleDescriptor.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VehicleDescriptor::release_label() {
  // @@protoc_insertion_point(field_release:transit_realtime.VehicleDescriptor.label)
  clear_has_label();
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VehicleDescriptor::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    set_has_label();
  } else {
    clear_has_label();
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.VehicleDescriptor.label)
}

// optional string license_plate = 3;
inline bool VehicleDescriptor::has_license_plate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VehicleDescriptor::set_has_license_plate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VehicleDescriptor::clear_has_license_plate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VehicleDescriptor::clear_license_plate() {
  license_plate_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_license_plate();
}
inline const ::std::string& VehicleDescriptor::license_plate() const {
  // @@protoc_insertion_point(field_get:transit_realtime.VehicleDescriptor.license_plate)
  return license_plate_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VehicleDescriptor::set_license_plate(const ::std::string& value) {
  set_has_license_plate();
  license_plate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transit_realtime.VehicleDescriptor.license_plate)
}
inline void VehicleDescriptor::set_license_plate(const char* value) {
  set_has_license_plate();
  license_plate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transit_realtime.VehicleDescriptor.license_plate)
}
inline void VehicleDescriptor::set_license_plate(const char* value, size_t size) {
  set_has_license_plate();
  license_plate_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transit_realtime.VehicleDescriptor.license_plate)
}
inline ::std::string* VehicleDescriptor::mutable_license_plate() {
  set_has_license_plate();
  // @@protoc_insertion_point(field_mutable:transit_realtime.VehicleDescriptor.license_plate)
  return license_plate_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VehicleDescriptor::release_license_plate() {
  // @@protoc_insertion_point(field_release:transit_realtime.VehicleDescriptor.license_plate)
  clear_has_license_plate();
  return license_plate_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VehicleDescriptor::set_allocated_license_plate(::std::string* license_plate) {
  if (license_plate != NULL) {
    set_has_license_plate();
  } else {
    clear_has_license_plate();
  }
  license_plate_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), license_plate);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.VehicleDescriptor.license_plate)
}

// -------------------------------------------------------------------

// EntitySelector

// optional string agency_id = 1;
inline bool EntitySelector::has_agency_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EntitySelector::set_has_agency_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EntitySelector::clear_has_agency_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EntitySelector::clear_agency_id() {
  agency_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_agency_id();
}
inline const ::std::string& EntitySelector::agency_id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.EntitySelector.agency_id)
  return agency_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EntitySelector::set_agency_id(const ::std::string& value) {
  set_has_agency_id();
  agency_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transit_realtime.EntitySelector.agency_id)
}
inline void EntitySelector::set_agency_id(const char* value) {
  set_has_agency_id();
  agency_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transit_realtime.EntitySelector.agency_id)
}
inline void EntitySelector::set_agency_id(const char* value, size_t size) {
  set_has_agency_id();
  agency_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transit_realtime.EntitySelector.agency_id)
}
inline ::std::string* EntitySelector::mutable_agency_id() {
  set_has_agency_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.EntitySelector.agency_id)
  return agency_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EntitySelector::release_agency_id() {
  // @@protoc_insertion_point(field_release:transit_realtime.EntitySelector.agency_id)
  clear_has_agency_id();
  return agency_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EntitySelector::set_allocated_agency_id(::std::string* agency_id) {
  if (agency_id != NULL) {
    set_has_agency_id();
  } else {
    clear_has_agency_id();
  }
  agency_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), agency_id);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.EntitySelector.agency_id)
}

// optional string route_id = 2;
inline bool EntitySelector::has_route_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EntitySelector::set_has_route_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EntitySelector::clear_has_route_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EntitySelector::clear_route_id() {
  route_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_route_id();
}
inline const ::std::string& EntitySelector::route_id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.EntitySelector.route_id)
  return route_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EntitySelector::set_route_id(const ::std::string& value) {
  set_has_route_id();
  route_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transit_realtime.EntitySelector.route_id)
}
inline void EntitySelector::set_route_id(const char* value) {
  set_has_route_id();
  route_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transit_realtime.EntitySelector.route_id)
}
inline void EntitySelector::set_route_id(const char* value, size_t size) {
  set_has_route_id();
  route_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transit_realtime.EntitySelector.route_id)
}
inline ::std::string* EntitySelector::mutable_route_id() {
  set_has_route_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.EntitySelector.route_id)
  return route_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EntitySelector::release_route_id() {
  // @@protoc_insertion_point(field_release:transit_realtime.EntitySelector.route_id)
  clear_has_route_id();
  return route_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EntitySelector::set_allocated_route_id(::std::string* route_id) {
  if (route_id != NULL) {
    set_has_route_id();
  } else {
    clear_has_route_id();
  }
  route_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), route_id);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.EntitySelector.route_id)
}

// optional int32 route_type = 3;
inline bool EntitySelector::has_route_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EntitySelector::set_has_route_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EntitySelector::clear_has_route_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EntitySelector::clear_route_type() {
  route_type_ = 0;
  clear_has_route_type();
}
inline ::google::protobuf::int32 EntitySelector::route_type() const {
  // @@protoc_insertion_point(field_get:transit_realtime.EntitySelector.route_type)
  return route_type_;
}
inline void EntitySelector::set_route_type(::google::protobuf::int32 value) {
  set_has_route_type();
  route_type_ = value;
  // @@protoc_insertion_point(field_set:transit_realtime.EntitySelector.route_type)
}

// optional .transit_realtime.TripDescriptor trip = 4;
inline bool EntitySelector::has_trip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EntitySelector::set_has_trip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EntitySelector::clear_has_trip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EntitySelector::clear_trip() {
  if (trip_ != NULL) trip_->::transit_realtime::TripDescriptor::Clear();
  clear_has_trip();
}
inline const ::transit_realtime::TripDescriptor& EntitySelector::trip() const {
  // @@protoc_insertion_point(field_get:transit_realtime.EntitySelector.trip)
  return trip_ != NULL ? *trip_ : *default_instance_->trip_;
}
inline ::transit_realtime::TripDescriptor* EntitySelector::mutable_trip() {
  set_has_trip();
  if (trip_ == NULL) {
    trip_ = new ::transit_realtime::TripDescriptor;
  }
  // @@protoc_insertion_point(field_mutable:transit_realtime.EntitySelector.trip)
  return trip_;
}
inline ::transit_realtime::TripDescriptor* EntitySelector::release_trip() {
  // @@protoc_insertion_point(field_release:transit_realtime.EntitySelector.trip)
  clear_has_trip();
  ::transit_realtime::TripDescriptor* temp = trip_;
  trip_ = NULL;
  return temp;
}
inline void EntitySelector::set_allocated_trip(::transit_realtime::TripDescriptor* trip) {
  delete trip_;
  trip_ = trip;
  if (trip) {
    set_has_trip();
  } else {
    clear_has_trip();
  }
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.EntitySelector.trip)
}

// optional string stop_id = 5;
inline bool EntitySelector::has_stop_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EntitySelector::set_has_stop_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EntitySelector::clear_has_stop_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EntitySelector::clear_stop_id() {
  stop_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_stop_id();
}
inline const ::std::string& EntitySelector::stop_id() const {
  // @@protoc_insertion_point(field_get:transit_realtime.EntitySelector.stop_id)
  return stop_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EntitySelector::set_stop_id(const ::std::string& value) {
  set_has_stop_id();
  stop_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transit_realtime.EntitySelector.stop_id)
}
inline void EntitySelector::set_stop_id(const char* value) {
  set_has_stop_id();
  stop_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transit_realtime.EntitySelector.stop_id)
}
inline void EntitySelector::set_stop_id(const char* value, size_t size) {
  set_has_stop_id();
  stop_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transit_realtime.EntitySelector.stop_id)
}
inline ::std::string* EntitySelector::mutable_stop_id() {
  set_has_stop_id();
  // @@protoc_insertion_point(field_mutable:transit_realtime.EntitySelector.stop_id)
  return stop_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EntitySelector::release_stop_id() {
  // @@protoc_insertion_point(field_release:transit_realtime.EntitySelector.stop_id)
  clear_has_stop_id();
  return stop_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EntitySelector::set_allocated_stop_id(::std::string* stop_id) {
  if (stop_id != NULL) {
    set_has_stop_id();
  } else {
    clear_has_stop_id();
  }
  stop_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), stop_id);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.EntitySelector.stop_id)
}

// -------------------------------------------------------------------

// TranslatedString_Translation

// required string text = 1;
inline bool TranslatedString_Translation::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TranslatedString_Translation::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TranslatedString_Translation::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TranslatedString_Translation::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& TranslatedString_Translation::text() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TranslatedString.Translation.text)
  return text_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TranslatedString_Translation::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transit_realtime.TranslatedString.Translation.text)
}
inline void TranslatedString_Translation::set_text(const char* value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transit_realtime.TranslatedString.Translation.text)
}
inline void TranslatedString_Translation::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transit_realtime.TranslatedString.Translation.text)
}
inline ::std::string* TranslatedString_Translation::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TranslatedString.Translation.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TranslatedString_Translation::release_text() {
  // @@protoc_insertion_point(field_release:transit_realtime.TranslatedString.Translation.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TranslatedString_Translation::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TranslatedString.Translation.text)
}

// optional string language = 2;
inline bool TranslatedString_Translation::has_language() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TranslatedString_Translation::set_has_language() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TranslatedString_Translation::clear_has_language() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TranslatedString_Translation::clear_language() {
  language_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_language();
}
inline const ::std::string& TranslatedString_Translation::language() const {
  // @@protoc_insertion_point(field_get:transit_realtime.TranslatedString.Translation.language)
  return language_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TranslatedString_Translation::set_language(const ::std::string& value) {
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:transit_realtime.TranslatedString.Translation.language)
}
inline void TranslatedString_Translation::set_language(const char* value) {
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:transit_realtime.TranslatedString.Translation.language)
}
inline void TranslatedString_Translation::set_language(const char* value, size_t size) {
  set_has_language();
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:transit_realtime.TranslatedString.Translation.language)
}
inline ::std::string* TranslatedString_Translation::mutable_language() {
  set_has_language();
  // @@protoc_insertion_point(field_mutable:transit_realtime.TranslatedString.Translation.language)
  return language_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TranslatedString_Translation::release_language() {
  // @@protoc_insertion_point(field_release:transit_realtime.TranslatedString.Translation.language)
  clear_has_language();
  return language_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TranslatedString_Translation::set_allocated_language(::std::string* language) {
  if (language != NULL) {
    set_has_language();
  } else {
    clear_has_language();
  }
  language_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:transit_realtime.TranslatedString.Translation.language)
}

// -------------------------------------------------------------------

// TranslatedString

// repeated .transit_realtime.TranslatedString.Translation translation = 1;
inline int TranslatedString::translation_size() const {
  return translation_.size();
}
inline void TranslatedString::clear_translation() {
  translation_.Clear();
}
inline const ::transit_realtime::TranslatedString_Translation& TranslatedString::translation(int index) const {
  // @@protoc_insertion_point(field_get:transit_realtime.TranslatedString.translation)
  return translation_.Get(index);
}
inline ::transit_realtime::TranslatedString_Translation* TranslatedString::mutable_translation(int index) {
  // @@protoc_insertion_point(field_mutable:transit_realtime.TranslatedString.translation)
  return translation_.Mutable(index);
}
inline ::transit_realtime::TranslatedString_Translation* TranslatedString::add_translation() {
  // @@protoc_insertion_point(field_add:transit_realtime.TranslatedString.translation)
  return translation_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::transit_realtime::TranslatedString_Translation >*
TranslatedString::mutable_translation() {
  // @@protoc_insertion_point(field_mutable_list:transit_realtime.TranslatedString.translation)
  return &translation_;
}
inline const ::google::protobuf::RepeatedPtrField< ::transit_realtime::TranslatedString_Translation >&
TranslatedString::translation() const {
  // @@protoc_insertion_point(field_list:transit_realtime.TranslatedString.translation)
  return translation_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace transit_realtime

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::transit_realtime::FeedHeader_Incrementality> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transit_realtime::FeedHeader_Incrementality>() {
  return ::transit_realtime::FeedHeader_Incrementality_descriptor();
}
template <> struct is_proto_enum< ::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship>() {
  return ::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship_descriptor();
}
template <> struct is_proto_enum< ::transit_realtime::VehiclePosition_VehicleStopStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transit_realtime::VehiclePosition_VehicleStopStatus>() {
  return ::transit_realtime::VehiclePosition_VehicleStopStatus_descriptor();
}
template <> struct is_proto_enum< ::transit_realtime::VehiclePosition_CongestionLevel> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transit_realtime::VehiclePosition_CongestionLevel>() {
  return ::transit_realtime::VehiclePosition_CongestionLevel_descriptor();
}
template <> struct is_proto_enum< ::transit_realtime::Alert_Cause> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transit_realtime::Alert_Cause>() {
  return ::transit_realtime::Alert_Cause_descriptor();
}
template <> struct is_proto_enum< ::transit_realtime::Alert_Effect> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transit_realtime::Alert_Effect>() {
  return ::transit_realtime::Alert_Effect_descriptor();
}
template <> struct is_proto_enum< ::transit_realtime::TripDescriptor_ScheduleRelationship> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transit_realtime::TripDescriptor_ScheduleRelationship>() {
  return ::transit_realtime::TripDescriptor_ScheduleRelationship_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_gtfs_2drealtime_2eproto__INCLUDED
